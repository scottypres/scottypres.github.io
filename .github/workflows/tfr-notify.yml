name: TFR West Palm Alerts

on:
  schedule:
    - cron: "0 * * * *"
  workflow_dispatch: {}

permissions:
  contents: write  # needed to commit the state file

jobs:
  poll:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check TFR feed and notify via Telegram
        env:
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          set -euo pipefail
          STATE_FILE="state/last_wpb.json"
          mkdir -p state

          python - <<'PYCODE'
          import datetime
          from zoneinfo import ZoneInfo
          import json
          import os
          import re
          import sys
          import urllib.parse
          import urllib.request
          import xml.etree.ElementTree as ET

          FEED_URL = "https://tfr.faa.gov/tfrapi/exportTfrList"
          TOKEN = os.getenv("TELEGRAM_TOKEN")
          CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
          STATE_FILE = "state/last_wpb.json"
          ET_ZONE = ZoneInfo("America/New_York")

          TZ_RE = re.compile(r"(Z|[+-]\d{2}:?\d{2})$")

          def fetch_json(url):
              with urllib.request.urlopen(url, timeout=15) as resp:
                  return json.loads(resp.read().decode())

          def fetch_detail(notam_id):
              url_id = notam_id.replace("/", "_")
              url = f"https://tfr.faa.gov/download/detail_{url_id}.xml"
              with urllib.request.urlopen(url, timeout=15) as resp:
                  xml_text = resp.read()
              root = ET.fromstring(xml_text)
              eff = root.find(".//dateEffective")
              exp = root.find(".//dateExpire")
              return {
                  "effective": eff.text if eff is not None else None,
                  "expires": exp.text if exp is not None else None,
              }

          def parse_utc(dt_str):
              if not dt_str:
                  return None
              dt_str = dt_str.strip()
              if not TZ_RE.search(dt_str):
                  dt_str = f"{dt_str}Z"
              try:
                  return datetime.datetime.fromisoformat(dt_str.replace("Z", "+00:00"))
              except ValueError:
                  return None

          def format_et(dt_obj):
              if not dt_obj:
                  return "N/A"
              return dt_obj.astimezone(ET_ZONE).strftime("%Y-%m-%d %a %I:%M %p %Z")

          def load_state(path):
              if not os.path.exists(path):
                  return {"seen": {}}
              with open(path, "r", encoding="utf-8") as f:
                  data = json.load(f)
              # Migrate old format
              if isinstance(data, dict) and "seen_ids" in data and "seen" not in data:
                  data = {"seen": {i: {} for i in data.get("seen_ids", [])}}
              if "seen" not in data:
                  data["seen"] = {}
              return data

          def save_state(path, data):
              with open(path, "w", encoding="utf-8") as f:
                  json.dump(data, f, indent=2, sort_keys=True)

          def send_telegram(body):
              if not (TOKEN and CHAT_ID):
                  print("Telegram env vars missing; skipping send.")
                  return
              data = urllib.parse.urlencode({
                  "chat_id": CHAT_ID,
                  "text": body,
              }).encode()
              url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
              req = urllib.request.Request(url, data=data, headers={"Content-Type": "application/x-www-form-urlencoded"})
              with urllib.request.urlopen(req, timeout=10) as resp:
                  print("Telegram status:", resp.status)

          def main():
              now = datetime.datetime.now(datetime.timezone.utc)
              feed = fetch_json(FEED_URL)
              wpb = [n for n in feed if ("west palm beach" in n.get("description","").lower()) or ("PBI" in n.get("description",""))]

              state = load_state(STATE_FILE)
              seen = state.get("seen", {})

              current_active = {}
              new_msgs = []
              revoke_msgs = []

              for n in wpb:
                  notam_id = n.get("notam_id")
                  if not notam_id:
                      continue
                  try:
                      detail = fetch_detail(notam_id)
                  except Exception as exc:  # pragma: no cover - network error logging
                      print(f"Failed detail fetch for {notam_id}: {exc}")
                      continue

                  eff_dt = parse_utc(detail.get("effective"))
                  exp_dt = parse_utc(detail.get("expires"))
                  if not exp_dt:
                      print(f"No expiration for {notam_id}; skipping.")
                      continue
                  if exp_dt <= now:
                      print(f"{notam_id} already expired; skipping.")
                      continue

                  current_active[notam_id] = {
                      "effective": eff_dt.isoformat() if eff_dt else None,
                      "expires": exp_dt.isoformat(),
                      "description": n.get("description", "").strip(),
                  }

                  if notam_id not in seen:
                      desc = n.get("description","").strip()
                      start_str = format_et(eff_dt)
                      end_str = format_et(exp_dt)
                      link = f"https://tfr.faa.gov/save_pages/detail_{notam_id.replace('/', '_')}.html"
                      new_msgs.append(f"- {notam_id}: {desc} (type: {n.get('type','?')})\n  Starts: {start_str}\n  Ends: {end_str}\n  Link: {link}")
                      seen[notam_id] = current_active[notam_id]
                  else:
                      # refresh stored expiration/effective in case it changed
                      seen[notam_id]["expires"] = exp_dt.isoformat()
                      seen[notam_id]["effective"] = eff_dt.isoformat() if eff_dt else None
                      seen[notam_id]["description"] = n.get("description", "").strip()

              # Handle revocations: items we had seen, not expired yet, now missing
              for notam_id, info in list(seen.items()):
                  exp_dt = parse_utc(info.get("expires"))
                  if exp_dt and exp_dt <= now:
                      seen.pop(notam_id, None)
                      continue
                  if notam_id not in current_active:
                      until = format_et(parse_utc(info.get("expires")))
                      start = format_et(parse_utc(info.get("effective")))
                      revoke_msgs.append(f"- {notam_id} revoked before expiration\n  Was: {start} to {until}")
                      seen.pop(notam_id, None)

              messages = []
              if new_msgs:
                  messages.append("New West Palm Beach TFR(s) detected:\n" + "\n".join(new_msgs))
              if revoke_msgs:
                  messages.append("TFR(s) revoked early:\n" + "\n".join(revoke_msgs))

              if messages:
                  full_msg = "\n\n".join(messages)
                  print(full_msg)
                  send_telegram(full_msg)
              else:
                  print("No new or revoked WPB NOTAMs.")

              state["seen"] = seen
              save_state(STATE_FILE, state)
              return True

          if __name__ == "__main__":
              main()
              sys.exit(0)
          PYCODE
