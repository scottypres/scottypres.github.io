<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Collection</title>
    <style>
        /* Add a general header class to apply common header styles across tables */
        #autocomplete-list {
            position: absolute;
            background: #fff;
            border: 1px solid #d4d4d4;
            z-index: 99;
        }

        .day-divider {
            border-right: 1px solid black;
            width: 0;
            /* No actual width, just the border */
        }

        .shear-detected {
            border: 3px solid white;
        }

        .shear-detected-hidden {
            border: 2px solid tnsparent !important;
            background-color: inherit !important;
            /* Optional: reset any coloring if needed */
        }

        #autocomplete-list div {
            padding: 10px;
            cursor: pointer;
        }

        #autocomplete-list div:hover {
            background-color: #e9e9e9;
        }

        .wind-arrow {
            display: inline-block;
            transform-origin: center;
            font-size: 14px;
            /* Additional styling here if needed */
        }

        .column-header {
            white-space: nowrap;
            background-color: white;
            text-align: center;
            font-family: Arial, sans-serif;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Add a general data cell class to apply common data cell styles */
        wind-arrow.rotate-0 {
            transform: rotate(0deg);
        }

        .wind-arrow.rotate-11-25 {
            transform: rotate(11.25deg);
        }

        .wind-arrow.rotate-22-50 {
            transform: rotate(22.50deg);
        }

        .wind-arrow.rotate-33-75 {
            transform: rotate(33.75deg);
        }

        .wind-arrow.rotate-45 {
            transform: rotate(45deg);
        }

        .wind-arrow.rotate-56-25 {
            transform: rotate(56.25deg);
        }

        .wind-arrow.rotate-67-50 {
            transform: rotate(67.50deg);
        }

        .wind-arrow.rotate-78-75 {
            transform: rotate(78.75deg);
        }

        .wind-arrow.rotate-90 {
            transform: rotate(90deg);
        }

        .wind-arrow.rotate-101-25 {
            transform: rotate(101.25deg);
        }

        .wind-arrow.rotate-112-50 {
            transform: rotate(112.50deg);
        }

        .wind-arrow.rotate-123-75 {
            transform: rotate(123.75deg);
        }

        .wind-arrow.rotate-135 {
            transform: rotate(135deg);
        }

        .wind-arrow.rotate-146-25 {
            transform: rotate(146.25deg);
        }

        .wind-arrow.rotate-157-50 {
            transform: rotate(157.50deg);
        }

        .wind-arrow.rotate-168-75 {
            transform: rotate(168.75deg);
        }

        .wind-arrow.rotate-180 {
            transform: rotate(180deg);
        }

        .wind-arrow.rotate-191-25 {
            transform: rotate(191.25deg);
        }

        .wind-arrow.rotate-202-50 {
            transform: rotate(202.50deg);
        }

        .wind-arrow.rotate-213-75 {
            transform: rotate(213.75deg);
        }

        .wind-arrow.rotate-225 {
            transform: rotate(225deg);
        }

        .wind-arrow.rotate-236-25 {
            transform: rotate(236.25deg);
        }

        .wind-arrow.rotate-247-50 {
            transform: rotate(247.50deg);
        }

        .wind-arrow.rotate-258-75 {
            transform: rotate(258.75deg);
        }

        .wind-arrow.rotate-270 {
            transform: rotate(270deg);
        }

        .wind-arrow.rotate-281-25 {
            transform: rotate(281.25deg);
        }

        .wind-arrow.rotate-292-50 {
            transform: rotate(292.50deg);
        }

        .wind-arrow.rotate-303-75 {
            transform: rotate(303.75deg);
        }

        .wind-arrow.rotate-315 {
            transform: rotate(315deg);
        }

        .wind-arrow.rotate-326-25 {
            transform: rotate(326.25deg);
        }

        .wind-arrow.rotate-337-50 {
            transform: rotate(337.50deg);
        }

        .wind-arrow.rotate-348-75 {
            transform: rotate(348.75deg);
        }

        .wind-arrow.rotate-360 {
            transform: rotate(360deg);
        }

        .data-cell {
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
        }

        .smalldate {
            font-size: 10px;
        }

        .small-font {
            font-size: 16px;
        }

        body {
            margin: 0;
            padding: 0;
        }

        .sticky-header {
            position: sticky;
            top: 0;
            background-color: white;
            z-index: 3;
        }




        .header h2 {
            /* Sticky positioning here is unnecessary as .sticky-header class already makes the header stick */
            margin: 0;
            /* The position, top, and background-color properties should be removed from here */
        }

        /* Add these CSS styles */
        th.daylight {
            border: 2px solid orange;
        }

        /* Updated CSS rule for first-column cells */
        table th:first-child,
        table td:first-child {
            position: sticky;
            left: 0;
            background-color: white;
            z-index: 2;

            min-width: 60px;
            max-width: 120px;
        }

        th span {
            font-size: 12px;
        }

        table {
            width: 100%;
            border-collapse: collapse;

        }

        th,
        td {
            min-width: 10px;
            /* Minimum width of cells */
            max-width: 50px;
            /* Maximum width of cells */
            border: 1px solid black;
            padding: 1px;
            text-align: center;
            font-family: Arial, sans-serif;
            overflow: hidden;
            /* If content is too wide, it will be clipped */
            text-overflow: ellipsis;
            /* If content is clipped, display an ellipsis ('...') */
            white-space: nowrap;
            /* Keep text on the same line */
        }

        .wind-arrow {
            display: inline-block;
            transform-origin: 50% 50%;
        }

        @for $i from 0 through 348 {
            $degrees: $i * 11.25;

            .wind-arrow.rotate-#{$degrees} {
                transform: rotate(#{$degrees}deg);
            }
        }

        /* Updated CSS rule for first-column cells under `tbody` to inherit the width */
        td:first-child {
            position: sticky;
            left: 0;
            background-color: white;
            z-index: 1;
        }

        td:not(:first-child) {
            white-space: nowrap;
            /* Prevent text wrapping in the data cells */
        }

        th {
            min-width: 20px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .grey-bg {
            /* Max grey level 75% */
            background-color: rgba(0, 0, 0, 0.75);
        }
    </style>
</head>

<body>

    <div id="zipcode-section">
        <label for="zipcodeInput">Enter Zipcode:</label>
        <input type="text" id="zipcodeInput" placeholder="Enter zipcode">
        <button id="fetchCoordinatesButton">Get Weather</button>
    </div>
    <div id="zipcode-section">
        <!-- ... existing HTML ... -->
        Tables: 
        <button id="toggleButton">Wind/Clouds</button>
        <button id="toggleTemperatureButton">Temperature</button>
        <br>
        Modifiers: 
        <button id="editThresholdsButton">Edit Wind Speed Thresholds</button>
        <button id="checkWindShearButton">Enable Wind Shear</button>
        <button id="toggleDaylightButton">All Hours</button>
        <br>
        Display: 
        <button id="toggleHighAltitudeButton">High Altitude</button>
        <button id="additionalVariablesButton">Enable Additional Variables</button>
        <br>
        <button id="bestDaysButton" disabled>Best Hours</button>

        <div id="bestDaysPopup" class="config-popup" style="display: none;">
            <div class="config-content">
                <label for="bestWindSpeed">Max Wind Speed</label>
                <input type="number" id="bestWindSpeed" value="15" min="0" /><br />
                <button id="applyBestDaysButton">Apply</button>

            </div>
        </div>


        <!-- ICON Table -->
        <div id="configPopup" class="config-popup" style="display: none;">
            <div class="config-content">
                <label for="blueThreshold">Blue Threshold (mph)</label>
                <input type="number" id="blueThreshold" value="4" min="0" /><br />
                <label for="greenThreshold">Green Threshold (mph)</label>
                <input type="number" id="greenThreshold" value="12" min="1" /><br />
                <label for="redThreshold">Red Threshold (mph)</label>
                <input type="number" id="redThreshold" value="20" min="2" /><br />
                <button id="submitThresholds">Submit</button>
            </div>



        </div>


        <table id="icon-table">
            <!-- The table will be populated by JavaScript -->
        </table>
        <br>
        <br>
        <!-- GFS Table -->
        <table id="gfs-table">
            <!-- The table will be populated by JavaScript -->
        </table>
        <!-- OpenMeteo Table -->






    </div>


    <script>

        let highAltitudeVisible = false;
        let windShearEnabled = false;
    let isWindShearCheckInProgress = false;
        
        const highPressureAltitudes = [400, 500, 600, 700, 800]; // hPa values to be toggled


        document.getElementById('toggleHighAltitudeButton').addEventListener('click', function () {
            // Toggle the flag
            highAltitudeVisible = !highAltitudeVisible;

            // Optionally, update button text or styling to reflect the state
            this.textContent = highAltitudeVisible ? 'Hide High Altitude' : 'Show High Altitude';
            fetchAllModelsData();
        });
        document.getElementById('checkWindShearButton').addEventListener('click', function () {
                console.log("Wind shear button clicked");
                windShearEnabled = !windShearEnabled;
                console.log(windShearEnabled);
                const button = this; // 'this' refers to the button element in a regular function.

                // Always display "Loading..." text and disable the button while processing
                button.textContent = 'Loading...';
                button.disabled = true;

                if (windShearEnabled) {
                    console.log('Wind Shear Enabled: Checking...');
                    checkAndApplyWindShear().then(() => {
                        // Once completed, set the text to reflect the current state
                        button.textContent = 'Disable Wind Shear';
                        button.disabled = false; // Re-enable the button
                    });
                } else {
                    console.log('Wind Shear Disabled: Removing styles...');
                    removeWindShearStyles();
                    // Set the button text to "Enable Wind Shear" after the styles have been removed
                    button.textContent = 'Enable Wind Shear';
                    button.disabled = false; // Re-enable the button
                }
                fetchAllModelsData();
            });
        function fillTableWithTemperature(table, weatherData) {
                const model = table.dataset.model; // Use the model attribute to customize the table for different data sources
                let tableHtml = '<tr>' + table.getElementsByTagName('tr')[0].innerHTML + '</tr>'; // Reuse the header rows for consistency

                const altitudeLevels = [10, 80, 1000, 180, 975, 950, 925, 900, 850, 800, 700, 600, 500, 400].reverse(); // Should match your data's altitude levels

                // Use the weatherData object to fill temperature data
                altitudeLevels.forEach(hPa => {
                    const temperatureKey = `temperature_${hPa}hPa`; // Must match the key used in your weatherData object for temperatures at different altitudes

                    if (weatherData.hourly.hasOwnProperty(temperatureKey)) {
                        // Convert hPa to feet for display
                        const displayAltitude = `${hPaToFeet(hPa)} ft`;

                        tableHtml += `<tr><th class="sticky-header">${displayAltitude}</th>`;

                        // Add temperature data cells
                        weatherData.hourly[temperatureKey].forEach(temp => {
                            const { backgroundColor, textColor } = getTemperatureColor(temp); // Get the color based on the temperature
                            tableHtml += `<td class="data-cell" style="background-color: ${backgroundColor}; color: ${textColor};">${Math.round(temp)}&deg;</td>`; // Display temperature with Fahrenheit symbol and gradient color
                        });

                        tableHtml += '</tr>';
                    }
                });

                table.innerHTML = tableHtml; // Update the table's HTML with the new rows
                table.dataset.showing = 'temperature'; // Update data attribute to indicate current data being shown
            }
            function getTemperatureColor(temperature) {
                    let percentage;
                    let backgroundColorRGB;
                    let textColor = 'black'; // Default text color

                    if (temperature >= 100) {
                        backgroundColorRGB = colors.maroon;
                    } else if (temperature >= 85) {
                        percentage = (temperature - 85) / (100 - 85);
                        backgroundColorRGB = interpolateColorRGB('red', 'maroon', percentage);
                    } else if (temperature >= 70) {
                        percentage = (temperature - 70) / (85 - 70);
                        backgroundColorRGB = interpolateColorRGB('blue', 'red', percentage);
                    } else if (temperature >= 40) {
                        percentage = (temperature - 40) / (70 - 40);
                        backgroundColorRGB = interpolateColorRGB('lightblue', 'blue', percentage);
                    } else if (temperature <= 32) {
                        backgroundColorRGB = colors.white;
                    } else { // Temperatures between 32 and 40
                        percentage = (temperature - 32) / (40 - 32);
                        backgroundColorRGB = interpolateColorRGB('white', 'lightblue', percentage);
                    }

                    // Set text color to white if background is dark
                    if (isColorDark(backgroundColorRGB.r, backgroundColorRGB.g, backgroundColorRGB.b)) {
                        textColor = 'white';
                    }

                    // Return the color in CSS rgb() format
                    const backgroundColor = `rgb(${backgroundColorRGB.r}, ${backgroundColorRGB.g}, ${backgroundColorRGB.b})`;
                    return { backgroundColor, textColor };
                }
        function checkAndApplyWindShear() {
                return new Promise((resolve, reject) => { // Wrap the function body in a new Promise
                    if (isWindShearCheckInProgress) {
                        console.log("Wind shear check is already in progress.");
                        reject("Wind shear check is already in progress."); // Reject the Promise if a check is already in progress
                        return;
                    }
                if (isWindShearCheckInProgress) {
                    console.log("Wind shear check is already in progress.");
                    return; // Abort if a check is already in progress
                }
                 
                isWindShearCheckInProgress = true; // Set flag to indicate processing
                console.log("Wind shear check starting...");

            // Select all tables that end in '-table', such as 'icon-table', 'gfs-table', etc.
            document.querySelectorAll('#icon-table').forEach(table => {
                
                console.log(`Checking wind shear for table with ID: ${table.id}`); // Log which table is being checked

                // Get all the rows (tr elements) of the current table, excluding the header row
                const rows = table.querySelectorAll('tr:not(:first-child)');

                // Iterate through each row, but not the last row since there's no row below it
                for (let rowIndex = 0; rowIndex < rows.length - 1; rowIndex++) {
                    const currentRow = rows[rowIndex];
                    const nextRow = rows[rowIndex + 1];

                    // Get all cells within the current row that contain wind speed and direction data
                    const currentRowWindCells = currentRow.querySelectorAll('td[data-wind-speed][data-wind-direction]');

                    // Get all cells within the next row that contain wind speed and direction data
                    const nextRowWindCells = nextRow.querySelectorAll('td[data-wind-speed][data-wind-direction]');

                    // Only compare cells if the next row has the same number of wind data cells
                    if (currentRowWindCells.length === nextRowWindCells.length) {
                        // Compare each cell from the current row to the corresponding cell in the next row
                        currentRowWindCells.forEach((cell, cellIndex) => {
                            const currentWindSpeed = parseFloat(cell.dataset.windSpeed);
                            const currentWindDirection = parseFloat(cell.dataset.windDirection);

                            const nextCell = nextRowWindCells[cellIndex];
                            const nextWindSpeed = parseFloat(nextCell.dataset.windSpeed);
                            const nextWindDirection = parseFloat(nextCell.dataset.windDirection);

                            // Log the wind speeds and directions being compared for shear
                            //console.log(`Row: ${rowIndex + 1}, Column: ${cellIndex + 1}, Current Wind Speed: ${currentWindSpeed}, Next Wind Speed: ${nextWindSpeed}`);
                            // console.log(`Row: ${rowIndex + 1}, Column: ${cellIndex + 1}, Current Wind Direction: ${currentWindDirection}, Next Wind Direction: ${nextWindDirection}`);

                            // Check if the difference between current and next wind speed exceeds the threshold and check wind direction difference
                            if (Math.abs(currentWindSpeed - nextWindSpeed) > 9 || Math.abs(currentWindDirection - nextWindDirection) > 45) {
                                // Apply the "shear-detected" class to current and corresponding cell in the next row
                                cell.classList.add('shear-detected');
                                nextCell.classList.add('shear-detected');

                                // Log that wind shear was detected between the two cells
                                // console.log(`Wind shear detected at Row: ${rowIndex + 1}, Column: ${cellIndex + 1}`);
                            }
                        });
                    }
                }
            });

             console.log("Wind shear check completed.");
                    isWindShearCheckInProgress = false; // Reset flag when done
                    resolve(); // Resolve the Promise when everything is done
                });
        }

        function removeWindShearStyles() {
            document.querySelectorAll('.shear-detected').forEach(cell => {
                cell.classList.remove('shear-detected');
            });
        }
        function toggleHighAltitude() {
            if (!highAltitudeVisible) {  // Check if the flag indicates altitude should be hidden
                // console.log('Hiding high altitude rows');
                const tables = document.querySelectorAll('table[id$="-table"]');
                tables.forEach(table => {
                    const rows = table.getElementsByTagName('tr');
                    // Skip the header row by starting the loop at index 1
                    for (let i = 1; i < rows.length; i++) {
                        const altitudeInFeet = rows[i].cells[0].innerText.replace(' ft', '');
                        if (parseInt(altitudeInFeet) > 5000) {
                            rows[i].style.display = 'none'; // Hide the row
                        }
                    }
                });
            } else {
                // console.log('Showing high altitude rows');
                const tables = document.querySelectorAll('table[id$="-table"]');
                tables.forEach(table => {
                    const rows = table.getElementsByTagName('tr');
                    // Skip the header row by starting the loop at index 1
                    for (let i = 1; i < rows.length; i++) {
                        const altitudeInFeet = rows[i].cells[0].innerText.replace(' ft', '');
                        if (parseInt(altitudeInFeet) > 5000) {
                            rows[i].style.display = ''; // Show the row
                        }
                    }
                });
            }
        }
        let daylightHoursShown = true;
        let userLocation = {
            latitude: 26.4187,   // Use a default latitude or prompt the user to enter a valid one.
            longitude: 81.4173,  // Use a default longitude or prompt the user to enter a valid one.
        };
        let additionalVariablesEnabled = false;
        document.getElementById('additionalVariablesButton').addEventListener('click', () => {
            additionalVariablesEnabled = !additionalVariablesEnabled; // Toggle the boolean value
            // console.log("Additional Variables Enabled:", additionalVariablesEnabled);

            // Update button text to reflect the current state
            document.getElementById('additionalVariablesButton').textContent =
                additionalVariablesEnabled ? "Disable Additional Variables" : "Enable Additional Variables";
            fetchAllModelsData();
            // Add any other code that should run when the toggle occurs
        });

        // Initialize global threshold variables
        lowWindThreshold = 7;
        medWindThreshold = 15;
        highWindThreshold = 20;
        // Declare this at the top to store the initial view

        let globalWeatherData = {};
        let bestWindSpeedThreshold = 15;

        document.getElementById('toggleDaylightButton').addEventListener('click', function () {
            toggleDaylightHours(); // Call the function to change the visibility of daylight hours in the tables
            daylightHoursShown = !daylightHoursShown; // Toggle the daylightHoursShown state
            this.textContent = daylightHoursShown ? 'All Hours' : 'Daylight';
            // console.log(daylightHoursShown);
            fetchAllModelsData();
        });

        function toggleDaylightHours() {
            const tables = document.querySelectorAll('table[id$="-table"]'); // Select all tables that end with '-table'
            tables.forEach(table => {
                const headerCells = table.querySelectorAll('tr:first-child th:not(:first-child)'); // Select all header cells except the first one

                headerCells.forEach((cell, index) => {
                    // Only change the display when the current state does not match the truthy 'daylight' class presence
                    const isDaylightClassPresent = cell.classList.contains('daylight');
                    if (daylightHoursShown && !isDaylightClassPresent) {
                        // If daylight hours are currently shown, hide the non-daylight cells (cells without the 'daylight' class)
                        cell.style.display = 'none';
                        [...table.querySelectorAll(`td:nth-child(${index + 2})`)].forEach(td => td.style.display = 'none');
                    } else if (!daylightHoursShown && isDaylightClassPresent) {
                        // If daylight hours are currently hidden, show all cells that are for daylight hours
                        cell.style.display = '';
                        [...table.querySelectorAll(`td:nth-child(${index + 2})`)].forEach(td => td.style.display = '');
                    }
                });
            });


        }
        document.getElementById('bestDaysButton').addEventListener('click', function () {
            const buttonText = this.textContent;
            if (buttonText === 'Best Hours') {
                // The button text is "Best Days", so show the popup
                document.getElementById('bestDaysPopup').style.display = 'flex';
            } else {
                // The button text is "Reset", so reset the tables by creating them again
                resetTables();
                // Change the button text back to "Best Days"
                this.textContent = 'Best Hours';
            }
        });
        function resetTables() {
            // Loop over each model to create the tables again using the stored data
            //  console.log('resetTables');
            Object.keys(globalWeatherData).forEach(model => {
                const tableId = `${model.toLowerCase()}-table`;
                createTable(tableId, globalWeatherData[model], model);
            });
            // After resetting the tables, update the toggle button text to reflect the content shown in the tables

            initialTableSetup();
        }

        // Event listener to handle when the user clicks the "Apply" button in the Best Days popup
        document.getElementById('applyBestDaysButton').addEventListener('click', function () {
            // Show "Loading..." and disable the button to prevent additional clicks during processing
            this.textContent = 'Loading...';
            this.disabled = true;

            // Get the value from the input field for the best wind speed threshold
            bestWindSpeedThreshold = parseFloat(document.getElementById('bestWindSpeed').value);
            setCookie('bestWindSpeed', bestWindSpeedThreshold, 365);
            // Perform the filtering operation asynchronously to allow the UI to show the loading state
            setTimeout(() => {
                filterBestDaysColumns();
                // After completing the filter operation, reset the Apply button and update the UI
                this.textContent = 'Apply';
                this.disabled = false;
                // Hide the best days filter popup
                document.getElementById('bestDaysPopup').style.display = 'none';
                // Change the Best Days button to Reset
                document.getElementById('bestDaysButton').textContent = 'Reset';
                // Show the Reset button

            }, 0);
        });

        function filterBestDaysColumns() {
            // Threshold in mph
            const bestWindSpeedThreshold = parseFloat(document.getElementById('bestWindSpeed').value);

            // Get tables containing wind speeds
            const tables = document.querySelectorAll('table[id$="-table"]');

            tables.forEach(table => {
                // Get all header cells (ignoring the first row which contains model names)
                const headers = table.querySelectorAll('tr:first-child th:not(:first-child)');
                // Get all rows to access speed values at specified altitudes
                const rows = table.querySelectorAll('tr:not(:first-child)');

                // Determine which rows correspond to altitudes 33, 262, and 361 ft
                const targetAltitudeRows = [...rows].filter(row => {
                    const altitudeText = row.cells[0].innerText.trim();
                    const altitude = parseInt(altitudeText.replace(' ft', ''), 10);
                    return [33, 262, 361].includes(altitude);
                });

                // Keep track of the last known day of week text to compare days


                // Iterate over each column (time slot) and check if values exceed the threshold
                headers.forEach((header, columnIndex) => {
                    // Extract day of week from the header cell, assuming the format is MM/DD\nDay\nHH\nAM/PM
                    const dayOfWeek = header.innerText.trim().split('\n')[1]; // Day of week is on the second line



                    // Check whether any of the wind speeds exceed the threshold
                    let columnOverThreshold = targetAltitudeRows.some(row => {
                        const windSpeedText = row.cells[columnIndex + 1].innerText.trim();
                        const windSpeed = parseFloat(windSpeedText);
                        return windSpeed > bestWindSpeedThreshold;
                    });

                    // Hide the whole column if the threshold is exceeded
                    if (columnOverThreshold) {
                        headers[columnIndex].style.display = 'none'; // Hide header cell
                        rows.forEach(row => {
                            row.cells[columnIndex + 1].style.display = 'none'; // Hide data cell
                        });
                    } else {
                        // Ensure the column is visible if it does not exceed the threshold
                        headers[columnIndex].style.display = ''; // Show header cell
                        rows.forEach(row => {
                            row.cells[columnIndex + 1].style.display = ''; // Show data cell
                        });
                    }
                });
            });

        }

        // After tables have been generated, enable the "Best Days" button
        function enableBestDaysButton() {
            const bestDaysButton = document.getElementById('bestDaysButton');
            if (bestDaysButton) {
                bestDaysButton.disabled = false; // Enable the button
            }
        }
        function getWindArrowClass(degrees) {

            // Normalize the degrees to ensure it is between 0 and 360
            degrees = (degrees + 180) % 360; // Add 180 degrees to flip the arrow direction
            // Round the degrees to the nearest 11.25 increment
            const roundedDegrees = Math.round(degrees / 11.25) * 11.25;
            // Replace dot with a dash for CSS class compatibility
            const classDegrees = roundedDegrees.toFixed(2).replace('.', '-');
            // Return the CSS class for the wind arrow rotation
            return 'wind-arrow rotate-' + classDegrees;
        }
        function initialTableSetup() {
            console.log('Initial Table Setup');
            if (!isUpdatingTables) {
                Object.keys(globalWeatherData).forEach(model => {
                    const tableId = `${model.toLowerCase()}-table`;
                    const dataTable = document.getElementById(tableId);
                    fillTableWithWindSpeed(dataTable, globalWeatherData[model]); // Show winds data first
                    dataTable.dataset.showing = 'winds'; // Indicate that winds are being shown
                })
            };
            // toggleDaylightHours();
            submitThresholdsAndRepaint();
        }
        function showConfigPopup() {
            document.getElementById('configPopup').style.display = 'flex';
        }
        // Fetch data for each model
        const baseUrls = {
            //openMeteo: 'https://api.open-meteo.com/v1/forecast',
            gfs: 'https://api.open-meteo.com/v1/gfs',
            icon: 'https://api.open-meteo.com/v1/dwd-icon'
        };
        //fetchAllModelsData();
        document.getElementById('editThresholdsButton').addEventListener('click', showConfigPopup); // assume editThresholdsButton is the ID of the button to show the popup
        function submitThresholdsAndRepaint() {
            // Get the threshold values from the input fields
            const blueThreshold = parseInt(document.getElementById('blueThreshold').value, 10);
            const greenThreshold = parseInt(document.getElementById('greenThreshold').value, 10);
            const redThreshold = parseInt(document.getElementById('redThreshold').value, 10);

            // Store them in cookies
            setCookie('blueThreshold', blueThreshold, 365);
            setCookie('greenThreshold', greenThreshold, 365);
            setCookie('redThreshold', redThreshold, 365);

            // Repaint the graph
            repaintGraphsWithNewThresholds(blueThreshold, greenThreshold, redThreshold);

            // Hide the config popup
            document.getElementById('configPopup').style.display = 'none';
        }

        document.getElementById('submitThresholds').addEventListener('click', submitThresholdsAndRepaint);
        function repaintGraphsWithNewThresholds(low, med, high) {
            // Assume these are the names of three different tables you have
            lowWindThreshold = low;
            medWindThreshold = med;
            highWindThreshold = high;

            const tableIds = ['icon-table', 'gfs-table']; // Add other table IDs as needed
            tableIds.forEach(tableId => {
                const table = document.getElementById(tableId);
                if (table.dataset.showing === 'winds') {
                    fillTableWithWindSpeed(table, globalWeatherData[table.dataset.model]);
                }
            });
        }
        function hPaToFeet(hPa) {
            const conversionTable = {
                1000: 110,
                975: 320,
                950: 500,
                925: 800,
                900: 1000,
                850: 1500,
                800: 1900,
                700: 3000,
                600: 4200,
                500: 5600,
                400: 7200
            };

            const meters = conversionTable[hPa];
            const feet = meters * 3.28084; // Convert meters to feet
            return Math.round(feet);
        }

        document.querySelectorAll('table[id$="-table"]').forEach(table => {
            table.dataset.showing = 'winds'; // Start with winds data shown
        });
        document.getElementById('fetchCoordinatesButton').addEventListener('click', () => {
            const zipcode = document.getElementById('zipcodeInput').value.trim();
            if (zipcode) {
                handleZipcodeFetch(zipcode);
            } else {
                alert('Please enter a valid zipcode.');
            }
        });
        let isUpdatingTables = false;
        async function fetchAllModelsData() {
            if (isUpdatingTables) return;
            isUpdatingTables = true;
            console.log("Inside fetchAllModelsData before Promise.all", new Date().toISOString());
            try {
                // Await all fetches to be completed using Promise.all
                await Promise.all(Object.entries(baseUrls).map(async ([model, baseUrl]) => {
                    console.log(`Fetching data for model "${model}"`, new Date().toISOString());
                    await checkAndFetchData(baseUrl, model);
                }));

                // console.log("Inside fetchAllModelsData after Promise.all", new Date().toISOString());

                // Now that we have all data, setup the tables and perform shear checks
                initialTableSetup();

            } catch (error) {
                console.error('Error fetching data for all models:', error);
            }
            isUpdatingTables = false;
        }

        // Fetch data for each model by calling the new fetchAllModelsData function
        //fetchAllModelsData();

        let commonParameters = [];

        async function getCoordinatesByZipcode(zipcode) {
            //console.log("getCoordinatesByZipcode called", new Date().toISOString());
            const zipApiUrl = `https://api.zippopotam.us/us/${zipcode}`;
            // console.log("getCoordinatesByZipcode start", new Date().toISOString());
            try {
                const response = await fetch(zipApiUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                if (data && data.places.length > 0) {
                    // Update the global location variable
                    userLocation = {
                        latitude: parseFloat(data.places[0].latitude),
                        longitude: parseFloat(data.places[0].longitude)
                    };
                    //console.log('Coordinates:', userLocation);
                    setCookie('zipcode', zipcode, 365); // Save for 365 days
                    // console.log('zip cookie saved');
                    // Now call the API with these coordinates for each model and update the table with new data
                    for (const model of Object.keys(baseUrls)) {
                        await checkAndFetchData(baseUrls[model], model);
                    }
                    initialTableSetup(); // Refresh the table setup


                } else {
                    alert('No coordinates found for the provided zipcode.');
                }
            } catch (error) {
                console.error('Failed to fetch coordinates:', error);
                alert('Failed to get coordinates. Please check the zipcode and try again.');
            }

            console.log("getCoordinatesByZipcode end", new Date().toISOString());


        };

        async function checkAndFetchData(baseUrl, model) {
            // console.log(`checkAndFetchData called for model ${model}`, new Date().toISOString());
            const dailyParameters = [
                'weather_code',
                'temperature_2m_max',
                'temperature_2m_min',
                'apparent_temperature_max',
                'apparent_temperature_min',
                'sunrise',
                'sunset',
                'uv_index_max',
                'precipitation_sum'
            ].join(',');



            const units = '&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto';
            let additionalParameters = ''; // Initialize additional parameters string


            // Check the model to determine the correct forecast_days parameter
            if (model.toLowerCase() === 'openmeteo') {
                additionalParameters += '&forecast_days=14'; // 14-day forecast for OpenMeteo
            } else if (model.toLowerCase() === 'icon') {
                additionalParameters += '&forecast_days=7'; // 7-day forecast for ICON
            }
            if (model.toLowerCase() === 'gfs') {
                additionalParameters += '&forecast_days=14'; // 14-day forecast for OpenMeteo
            }
            const zipcode = document.getElementById('zipcodeInput').value.trim();
            const lastApiCallKey = `lastApiCall_${model}_${zipcode}`;
            const now = Date.now();
            const cacheDuration = 15 * 60 * 1000; // 15 minutes in milliseconds
            const lastApiCallData = localStorage.getItem(lastApiCallKey);
            let shouldFetchData = true;

            // Check if we have cached data for this model and zipcode
            if (lastApiCallData) {
                const cachedData = JSON.parse(lastApiCallData);

                // Check if the cached data is still valid
                if (cachedData.zipcode === zipcode && now - cachedData.timestamp < cacheDuration) {
                    // console.log(`Using cached data for model "${model}"`, new Date().toISOString());
                    globalWeatherData[model] = cachedData.data;
                    createTable(`${model.toLowerCase()}-table`, cachedData.data, model);
                    shouldFetchData = false;
                }
            }

            // Fetch new data if necessary
            if (shouldFetchData) {

                if (model.toLowerCase() === 'icon') {
                    commonParameters = [
                        'temperature_2m', 'temperature_80m', 'temperature_180m',
                        'weather_code', 'relative_humidity_2m',
                        'dew_point_2m',
                        'cloud_cover',
                        'cloud_cover_low',
                        'cloud_cover_mid',
                        'cloud_cover_high',
                        'cloud_cover_1000hPa',
                        'cloud_cover_975hPa',
                        'cloud_cover_950hPa',
                        'cloud_cover_925hPa',
                        'cloud_cover_900hPa',
                        'cloud_cover_850hPa',
                        'cloud_cover_800hPa',
                        'cloud_cover_700hPa',
                        'cloud_cover_600hPa',
                        'cloud_cover_500hPa',
                        'cloud_cover_400hPa',
                        // Add new variables below
                        'wind_speed_10m',
                        'wind_speed_80m',
                        'wind_speed_180m', 'wind_gusts_10m',
                        'wind_direction_10m',
                        'wind_direction_80m',
                        'wind_direction_180m',
                        'temperature_1000hPa',
                        'temperature_975hPa',
                        'temperature_950hPa',
                        'temperature_925hPa',
                        'temperature_900hPa',
                        'temperature_850hPa',
                        'temperature_800hPa',
                        'temperature_700hPa',
                        'temperature_600hPa',
                        'temperature_500hPa',
                        'temperature_400hPa',
                        'windspeed_1000hPa',
                        'windspeed_975hPa',
                        'windspeed_950hPa',
                        'windspeed_925hPa',
                        'windspeed_900hPa',
                        'windspeed_850hPa',
                        'windspeed_800hPa',
                        'windspeed_700hPa',
                        'windspeed_600hPa',
                        'windspeed_500hPa',
                        'windspeed_400hPa',
                        'winddirection_1000hPa',
                        'winddirection_975hPa',
                        'winddirection_950hPa',
                        'winddirection_925hPa',
                        'winddirection_900hPa',
                        'winddirection_850hPa',
                        'winddirection_800hPa',
                        'winddirection_700hPa',
                        'winddirection_600hPa',
                        'winddirection_500hPa',
                        'winddirection_400hPa',
                        'cape',
                        'is_day'
                    ].join(',');
                }
                if (model.toLowerCase() === 'gfs' || model.toLowerCase() === 'openmeteo') {
                    commonParameters = [
                        'temperature_2m', 'temperature_80m', 'temperature_180m',
                        'weather_code', 'relative_humidity_2m',
                        'dew_point_2m',
                        'cloud_cover',
                        'cloud_cover_low',
                        'cloud_cover_mid',
                        'cloud_cover_high',
                        'cloud_cover_1000hPa',
                        'cloud_cover_975hPa',
                        'cloud_cover_950hPa',
                        'cloud_cover_925hPa',
                        'cloud_cover_900hPa',
                        'cloud_cover_850hPa',
                        'cloud_cover_800hPa',
                        'cloud_cover_700hPa',
                        'cloud_cover_600hPa',
                        'cloud_cover_500hPa',
                        'cloud_cover_400hPa',
                        // Add new variables below
                        'wind_speed_10m',
                        'wind_speed_80m',
                        'wind_speed_180m', 'wind_gusts_10m',
                        'wind_direction_10m',
                        'wind_direction_80m',
                        'wind_direction_180m',
                        'temperature_1000hPa',
                        'temperature_975hPa',
                        'temperature_950hPa',
                        'temperature_925hPa',
                        'temperature_900hPa',
                        'temperature_850hPa',
                        'temperature_800hPa',
                        'temperature_700hPa',
                        'temperature_600hPa',
                        'temperature_500hPa',
                        'temperature_400hPa',
                        'windspeed_1000hPa',
                        'windspeed_975hPa',
                        'windspeed_950hPa',
                        'windspeed_925hPa',
                        'windspeed_900hPa',
                        'windspeed_850hPa',
                        'windspeed_800hPa',
                        'windspeed_700hPa',
                        'windspeed_600hPa',
                        'windspeed_500hPa',
                        'windspeed_400hPa',
                        'winddirection_1000hPa',
                        'winddirection_975hPa',
                        'winddirection_950hPa',
                        'winddirection_925hPa',
                        'winddirection_900hPa',
                        'winddirection_850hPa',
                        'winddirection_800hPa',
                        'winddirection_700hPa',
                        'winddirection_600hPa',
                        'winddirection_500hPa',
                        'winddirection_400hPa',
                        'cape',
                        'is_day',
                        'precipitation_probability'
                    ].join(',');
                }





                const requestUrl = `${baseUrl}?latitude=${userLocation.latitude}&longitude=${userLocation.longitude}&hourly=${commonParameters}&daily=${dailyParameters}${units}${additionalParameters}`;

                try {
                    console.log('fetching new data');
                    // Request data from the weather API using the assembled URL
                    const response = await fetch(requestUrl);

                    // If the response is not okay, throw an error
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    // Parse the response as JSON
                    const weatherData = await response.json();

                    // Cache the new API data
                    localStorage.setItem(lastApiCallKey, JSON.stringify({
                        timestamp: now,
                        data: weatherData,
                        zipcode: zipcode
                    }));

                    // Populate the respective table with the fetched data
                    createTable(`${model.toLowerCase()}-table`, weatherData, model);

                    // Store the fetched data globally
                    globalWeatherData[model] = weatherData;

                    console.log(`Data fetched successfully for model ${model}`);
                } catch (error) {
                    // Log the error if fetching the data fails
                    console.error(`Failed to fetch data for model ${model}`, error);
                    // Optionally, handle the error in the UI
                }
            }

            // console.log(`checkAndFetchData finished for model ${model}`, new Date().toISOString());
        }



        function setCookie(name, value, days) {
            const d = new Date();
            d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
            const expires = `expires=${d.toUTCString()}`;
            document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)};${expires};path=/`;
        }

        function getCookie(name) {
            const cname = `${encodeURIComponent(name)}=`;
            const decodedCookie = decodeURIComponent(document.cookie);
            const ca = decodedCookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(cname) === 0) {
                    return c.substring(cname.length, c.length);
                }
            }
            return "";
        }





        window.onload = function () {
            //console.log("Window onload triggered", new Date().toISOString());

            // Get threshold values from cookies, if they exist
            const blueThreshold = getCookie('blueThreshold');
            const greenThreshold = getCookie('greenThreshold');
            const redThreshold = getCookie('redThreshold');

            // Update threshold inputs with cookie values
            if (blueThreshold) document.getElementById('blueThreshold').value = blueThreshold;
            if (greenThreshold) document.getElementById('greenThreshold').value = greenThreshold;
            if (redThreshold) document.getElementById('redThreshold').value = redThreshold;

            // Check for the presence of the zipcode cookie
            const savedZipcode = getCookie('zipcode');

            if (savedZipcode) {
                const zipcodeInput = document.getElementById('zipcodeInput');

                const fetchButton = document.getElementById('fetchCoordinatesButton');

                zipcodeInput.value = savedZipcode;
                //   console.log("Zip cookie loaded");
                // Check if fetchCoordinatesButton has already a click event listener that fetches the weather
                // If not, manually call the handleZipcodeFetch(zipcode) function after a short delay to ensure any setup logic has completed
                setTimeout(function () {
                    fetchButton.click();
                }, 0);
            }
            const savedBestWindSpeed = getCookie('bestWindSpeed');

            if (savedBestWindSpeed) {
                // If we have a saved value, use it as the best wind speed threshold
                bestWindSpeedThreshold = parseFloat(savedBestWindSpeed);
            } else {
                // If no value is saved, use default value
                bestWindSpeedThreshold = 15;
            }

            // Update the value in the input field
            document.getElementById('bestWindSpeed').value = bestWindSpeedThreshold;
            document.getElementById('toggleTemperatureButton').addEventListener('click', () => {
                toggleTemperatureTables();
            });
        };
        function toggleTemperatureTables() {
                Object.keys(globalWeatherData).forEach(model => {
                    const tableId = `${model.toLowerCase()}-table`;
                    const dataTable = document.getElementById(tableId);

                    // Check the current state and toggle accordingly
                     if (dataTable.dataset.showing !== 'temperature') {
                        // Currently showing something other than temperature, switch to temperature
                        fillTableWithTemperature(dataTable, globalWeatherData[model]);
                        dataTable.dataset.showing = 'temperature'; // Indicate that temperature is being shown
                    } else {
                        // Currently showing temperature, switch to wind speed
                        fillTableWithWindSpeed(dataTable, globalWeatherData[model]);
                        dataTable.dataset.showing = 'winds'; // Indicate that winds are being shown
                    }
                });
            }
        async function handleZipcodeFetch(zipcode) {
            // Disable the button and recent search links to prevent multiple fetches
            document.getElementById('fetchCoordinatesButton').disabled = true;
            document.querySelectorAll('.recent-search').forEach(elem => elem.style.pointerEvents = 'none');

            // Fetch the coordinates and update the tables
            await getCoordinatesByZipcode(zipcode);
            // Re-enable the button and the recent search links
            document.getElementById('fetchCoordinatesButton').disabled = false;
            document.querySelectorAll('.recent-search').forEach(elem => elem.style.pointerEvents = '');
        }
        function expandDaylightHours(isDayArray) {
            let foundFirstOne = false; // Flag that becomes true when we encounter the first '1'
            let lastZeroBeforeOneIndex = -1; // Store the index of the last '0' before the sequence of '1's

            // Iterate over the array
            for (let i = 0; i < isDayArray.length; i++) {
                if (isDayArray[i] === 1) {
                    foundFirstOne = true;
                    // If this is the first '1', change the previous '0' to '1'
                    if (lastZeroBeforeOneIndex !== -1) {
                        isDayArray[lastZeroBeforeOneIndex] = 1;
                        lastZeroBeforeOneIndex = -1; // Reset the index
                    }
                } else if (foundFirstOne) {
                    // If we found the sequence of '1's and now we encountered a '0', change it to '1' and reset flags
                    isDayArray[i] = 1;
                    foundFirstOne = false; // Reset the flag until we find another '1'
                } else {
                    // If we have not encountered the first '1' yet, store the index
                    lastZeroBeforeOneIndex = i;
                }
            }
            return isDayArray;
        }

        function createTable(tableId, weatherData, model) {
            // console.log('createTable');
            console.log(globalWeatherData);
            const altitudeLabels = [1000, 975, 950, 925, 900, 850, 800, 700, 600, 500, 400].reverse();
            const timestamps = weatherData.hourly.time;
            const dataTable = document.getElementById(tableId);


            let tableHtml = `<tr><th>${model.replace('Meteo', '<br>Meteo')}</th>`;
            let currentDay = null; // Variable to store the current day as you loop through the timestamps
            // Assuming that weatherData.hourly.is_day is an array with the same length as timestamps
            let isDayArray = weatherData.hourly.is_day;

            // Add date headers
            //console.log(isDayArray);
            timestamps.forEach((timestamp, index) => {
                const date = new Date(timestamp);
                const day = date.getDate();
                const month = date.getMonth() + 1;
                const dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'short' }).slice(0, 2); // Use first two letters
                const hour = date.getHours();
                const hour12 = hour % 12 || 12; // Convert to 12-hour format
                const ampm = hour >= 12 ? 'PM' : 'AM';
                // Determine if the timestamp corresponds to daylight using is_day array
                const isDaylight = isDayArray[index] === 1;
                const daylightClass = isDaylight ? 'daylight' : '';


                // Add "daylight" class to header cells of daylight hours
                //const isDaylight = hour >= 6 && hour < 18;
                // const headerClass = isDaylight ? 'daylight' : '';

                headerClass = '';
                tableHtml += `<th class="column-header ${daylightClass}">
                    <span class="smalldate">${month}/${day}</span><br>
                    <span class="small-font">${dayOfWeek}</span><br>
                    <span class="small-font">${hour12}</span><br><span class="small-font">${ampm}</span>
                  </th>`;
                enableBestDaysButton();
            });


            tableHtml += '</tr>';

            // Add rows for each altitude
            altitudeLabels.forEach(hPa => {
                // Convert hPa to feet for the display label
                const feet = hPaToFeet(hPa);

                // Start the table row with the altitude label
                tableHtml += `<tr><th class="sticky-header">${feet} ft</th>`;

                // Presuming the weatherData variable holds your cloud cover data indexed by hPa, 
                // e.g., `cloud_cover_1000hPa`, `cloud_cover_975hPa`, etc.
                const cloudCoverKey = `cloud_cover_${hPa}hPa`;
                const allShearCells = document.querySelectorAll('.shear-detected, .shear-detected-hidden');
                allShearCells.forEach(cell => {
                    cell.classList.remove('shear-detected');
                });
                // Check if the cloud cover data exists for this altitude level
                if (weatherData.hourly.hasOwnProperty(cloudCoverKey)) {
                    // Add a data cell for each time interval
                    weatherData.hourly[cloudCoverKey].forEach(cloudCover => {
                        // Calculate the background color based on cloud cover percentage
                        const bgColor = `rgba(0, 0, 0, ${cloudCover * 0.75 / 100})`;

                        // Append the data cell with styling for cloud cover
                        tableHtml += `<td class="grey-bg" style="background-color: ${bgColor}"></td>`;
                    });
                } else {
                    // If cloud cover data does not exist for this pressure altitude (hPa), span across all time intervals
                    tableHtml += `<td colspan="${weatherData.hourly.time.length}" class="data-cell">Data not available</td>`;
                    console.log('cloud cover data does not exist for this pressure');
                    console.log(cloudCoverKey);
                }

                // Close the table row
                tableHtml += '</tr>';
            });

            dataTable.innerHTML = tableHtml;




            dataTable.dataset.model = model;
            //console.log(`Listeners added for ${model} model`);
        }

        document.getElementById('toggleButton').addEventListener('click', toggleWindClouds);
        document.getElementById('toggleButton').textContent = 'Winds/Clouds'; // Default text
        function toggleWindClouds() {
            Object.keys(globalWeatherData).forEach(model => {
                const tableId = `${model.toLowerCase()}-table`;
                const dataTable = document.getElementById(tableId);
                const currentDisplay = dataTable.dataset.showing;

                if (currentDisplay === 'clouds') {
                    // Display wind data
                    fillTableWithWindSpeed(dataTable, globalWeatherData[model]);
                    dataTable.dataset.showing = 'winds';
                } else {
                    // Display cloud cover data
                    fillTableWithCloudCover(dataTable, globalWeatherData[model]);
                    dataTable.dataset.showing = 'clouds';
                }
            });


        }



        // Call this function to set the initial state of the button

        function fillTableWithWindSpeed(table, weatherData) {
            console.log('Fill Wind Table Start');
            let tableHtml = '<tr>' + table.getElementsByTagName('tr')[0].innerHTML + '</tr>';
            const altitudeLevels = [10, 80, 1000, 180, 975, 950, 925, 900, 850, 800, 700, 600, 500, 400].reverse(); // Order hPa values and feet values in descending order
            let gustRowAdded = false; // Flag to control the addition of the gust row
            altitudeLevels.forEach(alt => {
                let windSpeedKey, windDirectionKey;
                let displayAltitude; // Define a variable to hold our display altitude

                if (alt === 10 || alt === 80 || alt === 180) {
                    // Handle the specific feet values (10m, 80m, 180m are in meters, need conversion to feet)
                    const altInFeet = Math.round(alt * 3.28084); // Convert meters to feet, rounding to the nearest whole number
                    windSpeedKey = `wind_speed_${alt}m`;
                    windDirectionKey = `wind_direction_${alt}m`;
                    displayAltitude = `${altInFeet} ft`; // Display in feet
                } else {
                    // Handle hPa values and convert to feet for display
                    windSpeedKey = `windspeed_${alt}hPa`;
                    windDirectionKey = `winddirection_${alt}hPa`;
                    displayAltitude = `${hPaToFeet(alt)} ft`; // Covert hPa to feet and display in feet
                }

                // Check if wind data exists for this particular elevation
                if (weatherData.hourly.hasOwnProperty(windSpeedKey) && weatherData.hourly.hasOwnProperty(windDirectionKey)) {
                    tableHtml += `<tr><th class="sticky-header">${displayAltitude}</th>`;

                    // Iterate over wind speeds and directions together
                    weatherData.hourly[windSpeedKey].forEach((windSpeed, idx) => {
                        const windDirection = weatherData.hourly[windDirectionKey][idx];
                        const windArrowClass = getWindArrowClass(windDirection);
                        const roundedWindSpeed = windSpeed !== null ? Math.round(windSpeed) : 'N/A';

                        // Get the background and text color based on the wind speed
                        const { backgroundColor, textColor } = getWindSpeedColor(roundedWindSpeed);
                        const windArrowUnicode = getWindDirectionArrow(windDirection);
                        // Add wind speed and a Unicode arrow for wind direction with the proper rotation
                        tableHtml += `<td class="data-cell" style="background-color: ${backgroundColor}; color: ${textColor};"
                    data-wind-speed="${roundedWindSpeed}" data-wind-direction="${windDirection}">
                    <div>${roundedWindSpeed}</div>
                    <div class="${windArrowClass}">${windArrowUnicode}</div>
                </td>`;
                    });

                    tableHtml += '</tr>';

                }
                if (windShearEnabled) {
                    console.log('Wind Shear Enabled: Checking...');
                    // Asynchronously call the wind shear check function
                    checkAndApplyWindShear().then(() => {
                        // Once completed, set the text to reflect the current state
                        this.textContent = 'Disable Wind Shear';
                        this.disabled = false; // Re-enable the button
                    });
                } else {
                    console.log('Wind Shear Disabled: Removing styles...');
                    removeWindShearStyles();
                    this.textContent = 'Enable Wind Shear';
                    this.disabled = false; // Re-enable the button
                }
            });

            // Finally, set the table's HTML to the newly created rows
            table.innerHTML = tableHtml;

            const windGustsKey = `wind_gusts_10m`;
            if (weatherData.hourly.hasOwnProperty(windGustsKey)) {
                // Start the gusts table row with a descriptive header
                tableHtml += `<tr><th class="sticky-header">Gusts</th>`;

                // Add a data cell for each time interval with wind gusts data
                weatherData.hourly[windGustsKey].forEach((windGust, idx) => {
                    const roundedWindGust = windGust !== null ? Math.round(windGust) : 'N/A';

                    // Get the background and text color based on the wind gust speed
                    const { backgroundColor, textColor } = getWindSpeedColor(roundedWindGust);

                    // Add wind gust value with the appropriate color coding
                    tableHtml += `<td class="data-cell" style="background-color: ${backgroundColor}; color: ${textColor};">
                    <div>${roundedWindGust}</div>
                  </td>`;
                });

                // Close the gusts table row
                tableHtml += '</tr>';

            }
            if (additionalVariablesEnabled) {
                // Assuming weatherData.hourly['cape'] is an array of CAPE values at hourly intervals
                if (weatherData.hourly.hasOwnProperty('cape')) {
                    // Add CAPE row header
                    tableHtml += `<tr><th class="sticky-header">CAPE</th>`;

                    // Add CAPE data cells for each time interval
                    weatherData.hourly['cape'].forEach(capeValue => {
                        const { backgroundColor, textColor } = getCAPEColor(capeValue); // Get colors based on value

                        // Add CAPE data cells with gradient background and contrast text
                        tableHtml += `<td class="data-cell" style="background-color: ${backgroundColor}; color: ${textColor};">${capeValue}</td>`;
                    });

                    // Close the CAPE table row
                    tableHtml += '</tr>';
                }
            }
            if (additionalVariablesEnabled && (table.id === 'gfs-table' || table.id === 'openmeteo-table')) {
                // Precipitation probability only exists for certain models
                if (weatherData.hourly.hasOwnProperty('precipitation_probability')) {
                    // Add precipitation probability row header
                    tableHtml += '<tr><th class="sticky-header">Precip %</th>';

                    // Add precipitation probability data cells for each time interval
                    weatherData.hourly['precipitation_probability'].forEach(precipProbability => {
                        const { backgroundColor, textColor } = getPrecipitationProbabilityColor(precipProbability);

                        // Add precipitation probability cells with interpolated background color
                        tableHtml += `<td class="data-cell" style="background-color: ${backgroundColor}; color: ${textColor};">${precipProbability}%</td>`;
                    });

                    // Close the precipitation probability table row
                    tableHtml += '</tr>';
                }
            }
            // Finally, set the table's HTML to the newly created rows
            table.innerHTML = tableHtml;
            toggleHighAltitude();
            toggleDaylightHours();


        }
        function getCAPEColor(capeValue) {
            let percentage;
            let backgroundColorRGB;
            let textColor = 'black'; // Default text color

            if (capeValue >= 2000) {
                backgroundColorRGB = { r: 255, g: 0, b: 0 }; // Red
            } else if (capeValue >= 1200) {
                percentage = (capeValue - 1200) / (2000 - 1200);
                backgroundColorRGB = interpolateColorRGB('yellow', 'red', percentage);
            } else if (capeValue >= 800) {
                percentage = (capeValue - 800) / (1200 - 800);
                backgroundColorRGB = interpolateColorRGB('green', 'yellow', percentage);
            } else if (capeValue >= 400) {
                percentage = (capeValue - 400) / (800 - 400);
                backgroundColorRGB = interpolateColorRGB('lightblue', 'green', percentage);
            } else {
                percentage = capeValue / 400;
                backgroundColorRGB = interpolateColorRGB('darkblue', 'lightblue', percentage);
            }

            // Set text color to white if background is dark
            if (isColorDark(backgroundColorRGB.r, backgroundColorRGB.g, backgroundColorRGB.b)) {
                textColor = 'white';
            }

            // Return the color in CSS rgb() format
            const backgroundColor = `rgb(${backgroundColorRGB.r}, ${backgroundColorRGB.g}, ${backgroundColorRGB.b})`;
            return { backgroundColor, textColor };
        }
        const colors = {
             maroon: { r: 128, g: 0, b: 0 }, // Maroon color
            blue: { r: 0, g: 0, b: 255 },
            green: { r: 0, g: 255, b: 0 },
            red: { r: 255, g: 0, b: 0 },
            yellow: { r: 255, g: 255, b: 0 },
            white: { r: 255, g: 255, b: 255 }, // Adding white
            lightblue: { r: 173, g: 216, b: 230 }, // Light blue color
            darkblue: { r: 0, g: 0, b: 139 } // Dark blue color
        };

        async function refreshWeatherDataAndTables(zipcode) {
            console.log('refreshWeatherDataAndTables');
            // Fetch coordinates from zipcode
            await getCoordinatesByZipcode(zipcode);

            // Fetch weather data
            await fetchAllModelsData();

            // Update tables (if necessary)
            updateWeatherTables();


        }

        function isColorDark(r, g, b) {
            // Calculate the luminance of the color using the approximate formula:
            // luminance = 0.299*R + 0.587*G + 0.114*B
            const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
            // If luminance is less than 128, we will consider the color to be "dark"
            return luminance < 128;
        }
        // Helper function to get the background color based on the wind speed
        function getWindSpeedColor(windSpeed) {
            let backgroundColorRGB;
            let textColor = 'black'; // Default text color

            if (windSpeed === 'N/A') {
                backgroundColorRGB = { r: 255, g: 255, b: 255 }; // White background
                textColor = 'black';
            } else if (windSpeed <= lowWindThreshold) {
                backgroundColorRGB = { r: 0, g: 0, b: 255 }; // Blue background
            } else if (windSpeed >= highWindThreshold) {
                backgroundColorRGB = { r: 255, g: 0, b: 0 }; // Red background
            } else if (windSpeed <= medWindThreshold) {
                // Interpolating blue to green
                backgroundColorRGB = interpolateColorRGB('blue', 'green', (windSpeed - lowWindThreshold) / (medWindThreshold - lowWindThreshold));
            } else {
                // Interpolating green to red
                backgroundColorRGB = interpolateColorRGB('green', 'red', (windSpeed - medWindThreshold) / (highWindThreshold - medWindThreshold));
            }
            isColorDark();
            // Set text color to white if background is dark
            if (isColorDark(backgroundColorRGB.r, backgroundColorRGB.g, backgroundColorRGB.b)) {
                textColor = 'white';
            }

            // Return the color in CSS rgb() format
            const backgroundColor = `rgb(${backgroundColorRGB.r}, ${backgroundColorRGB.g}, ${backgroundColorRGB.b})`;
            return { backgroundColor, textColor };
        }
        function getPrecipitationProbabilityColor(value) {
            const backgroundColor = interpolateColorRGB('white', 'darkblue', value / 100);
            const textColor = isColorDark(backgroundColor.r, backgroundColor.g, backgroundColor.b) ? 'white' : 'black';
            return { backgroundColor: `rgb(${backgroundColor.r}, ${backgroundColor.g}, ${backgroundColor.b})`, textColor };
        }
        // Modify interpolate to return an object
        function interpolateColorRGB(color1, color2, percentage) {

            // Start and end colors as rgb objects
            const startColor = colors[color1];
            const endColor = colors[color2];

            // Make sure the color names are valid
            if (!startColor || !endColor) {
                throw new Error(`Invalid color names: "${color1}" or "${color2}"`);
            }

            // Interpolate each color channel
            const r = Math.round(startColor.r + (endColor.r - startColor.r) * percentage);
            const g = Math.round(startColor.g + (endColor.g - startColor.g) * percentage);
            const b = Math.round(startColor.b + (endColor.b - startColor.b) * percentage);

            // Return the interpolated color as an object
            return { r, g, b };
        }



        function fillTableWithCloudCover(table, weatherData) {
            console.log('Fill cloud start');
            const model = table.dataset.model;
            // Update showing attribute here
            table.dataset.showing = 'clouds';
            createTable(table.id, weatherData, model); // Reuse createTable function
            toggleHighAltitude();
            toggleDaylightHours();

        }
        // Initialize the tables to display clouds by default
        document.querySelectorAll('table[id$="-table"]').forEach(table => {
            table.dataset.showing = 'clouds'; // Default view
        });
        // Function to convert degrees to Unicode arrows with text-style rendering
        function getWindDirectionArrow(degrees) {
            if (typeof degrees === 'undefined' || degrees === null) {
                return ''; // Return empty string if the direction is undefined or null
            }
            const arrows = {
                N: '&#x2191;&#xFE0E;', // Upwards arrow
                NE: '&#x2197;&#xFE0E;', // North East arrow
                E: '&#x2192;&#xFE0E;', // Rightwards arrow
                SE: '&#x2198;&#xFE0E;', // South East arrow
                S: '&#x2193;&#xFE0E;', // Downwards arrow
                SW: '&#x2199;&#xFE0E;', // South West arrow
                W: '&#x2190;&#xFE0E;', // Leftwards arrow
                NW: '&#x2196;&#xFE0E;'  // North West arrow
            };

            // Convert the degrees to an arrow string with the given mapping
            const directions = [
                { direction: 'N', range: [337.5, 360], rangeStart: [0, 22.5] },
                { direction: 'NE', range: [22.5, 67.5] },
                { direction: 'E', range: [67.5, 112.5] },
                { direction: 'SE', range: [112.5, 157.5] },
                { direction: 'S', range: [157.5, 202.5] },
                { direction: 'SW', range: [202.5, 247.5] },
                { direction: 'W', range: [247.5, 292.5] },
                { direction: 'NW', range: [292.5, 337.5] }
            ];

            for (let i = 0; i < directions.length; i++) {
                const { direction, range, rangeStart } = directions[i];
                if ((degrees >= range[0] && degrees < range[1]) || (rangeStart && degrees >= rangeStart[0] && degrees < rangeStart[1])) {
                    return arrows[direction]; // Return the Unicode arrow character for the direction
                }
            }
            return ''; // Return empty string if the direction does not fall within known ranges
        }


    </script>

</body>

</html>