<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soar Forecaster</title>
    <style>
        /* Add a general header class to apply common header styles across tables */
        .sticky-container {
    position: fixed;
    bottom: 15px;
    background-color: white;
    z-index: 10;
    padding: 10px; /* Adjust padding as needed */
    box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Keep the shadow if desired */
    display: inline-block; /* Change to inline-block */
    box-sizing: border-box; /* Padding inside the width */
}
.small-text-cell {
    font-size: 12px; /* Adjust to your preferred size */
}
.cape-cell {
    font-size: 12px; /* Adjust to whatever size you prefer for the CAPE cell text */
}
        #autocomplete-list {
            position: absolute;
            background: #fff;
            border: 1px solid #d4d4d4;
            z-index: 99;
        }

        

        .shear-detected {
            border: 3px solid white;
        }

        

        #autocomplete-list div {
            padding: 10px;
            cursor: pointer;
        }

        #autocomplete-list div:hover {
            background-color: #e9e9e9;
        }

      


        .column-header {
            white-space: nowrap;
            background-color: white;
            text-align: center;
            font-family: Arial, sans-serif;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Add a general data cell class to apply common data cell styles */
        .wind-arrow.rotate-0 {
    transform: rotate(0deg);
}

.wind-arrow.rotate-22-5 {
    transform: rotate(22.5deg);
}

.wind-arrow.rotate-45 {
    transform: rotate(45deg);
}

.wind-arrow.rotate-67-5 {
    transform: rotate(67.5deg);
}

.wind-arrow.rotate-90 {
    transform: rotate(90deg);
}

.wind-arrow.rotate-112-5 {
    transform: rotate(112.5deg);
}

.wind-arrow.rotate-135 {
    transform: rotate(135deg);
}

.wind-arrow.rotate-157-5 {
    transform: rotate(157.5deg);
}

.wind-arrow.rotate-180 {
    transform: rotate(180deg);
}

.wind-arrow.rotate-202-5 {
    transform: rotate(202.5deg);
}

.wind-arrow.rotate-225 {
    transform: rotate(225deg);
}

.wind-arrow.rotate-247-5 {
    transform: rotate(247.5deg);
}

.wind-arrow.rotate-270 {
    transform: rotate(270deg);
}

.wind-arrow.rotate-292-5 {
    transform: rotate(292.5deg);
}

.wind-arrow.rotate-315 {
    transform: rotate(315deg);
}

.wind-arrow.rotate-337-5 {
    transform: rotate(337.5deg);
}

.wind-arrow.rotate-360 {
    transform: rotate(360deg);
}

        .data-cell {
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
        }

        .smalldate {
            font-size: 10px;
        }

        .small-font {
            font-size: 16px;
        }

        body {
            margin: 0;
            padding: 0;
        }

        .sticky-header {
            position: sticky;
            top: 0;
            background-color: white;
            z-index: 3;
        }




        .header h2 {
            /* Sticky positioning here is unnecessary as .sticky-header class already makes the header stick */
            margin: 0;
            /* The position, top, and background-color properties should be removed from here */
        }

        /* Add these CSS styles */
        th.daylight {
            border: 2px solid orange;
        }

        /* Updated CSS rule for first-column cells */
        table th:first-child,
        table td:first-child {
            position: sticky;
            left: 0;
            background-color: white;
            z-index: 2;

            min-width: 60px;
            max-width: 120px;
        }

        th span {
            font-size: 12px;
        }

        table {
            width: 100%;
            border-collapse: collapse;

        }

        th,
        td {
            min-width: 10px;
            /* Minimum width of cells */
            max-width: 50px;
            /* Maximum width of cells */
            border: 1px solid black;
            padding: 1px;
            text-align: center;
            font-family: Arial, sans-serif;
            overflow: hidden;
            /* If content is too wide, it will be clipped */
            text-overflow: ellipsis;
            /* If content is clipped, display an ellipsis ('...') */
            white-space: nowrap;
            /* Keep text on the same line */
        }

        .wind-arrow {
            display: inline-block;
            transform-origin: 50% 50%;
        }

        

        /* Updated CSS rule for first-column cells under `tbody` to inherit the width */
        td:first-child {
            position: sticky;
            left: 0;
            background-color: white;
            z-index: 1;
        }

        td:not(:first-child) {
            white-space: nowrap;
            /* Prevent text wrapping in the data cells */
        }

        th {
            min-width: 20px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .grey-bg {
            /* Max grey level 75% */
            background-color: rgba(0, 0, 0, 0.75);
        }
        /* Additional CSS for rows and columns */
.button-row {
    display: flex; /* Align items horizontally */
    flex-direction: column; /* Align items vertically */
    align-items: flex-start; /* Align items to the start */
    margin-bottom: 10px; /* Spacing between rows */
}

.button-column {
    display: flex;
    flex-direction: column; /* Stack the header and buttons vertically */
    margin-right: 15px; /* Spacing between columns */
}

.column-header {
    margin-bottom: 10px; /* Spacing between header and buttons */
    font-weight: bold; /* Optional: make it bold */
}

#editButton {
    position: fixed; /* Fixed position relative to the viewport */
    bottom: 0px;      /* Set a top offset */
    left: 0px;    /* Set a right offset */
    z-index: 100;   /* Higher z-index to ensure it's above other content */
    width: 65px;   /* Set a fixed width */
    height: 28px;   /* Set a fixed height */
    padding: 5px 5px; /* Optional: Adjust padding to match desired appearance */
    font-size: 14px; /* Optional: Adjust font size as needed */
    line-height: 1; /* Optional: Adjust line spacing for better readability */
    display: flex;
    justify-content: center;
    align-items: center;
    zoom: 1;
}
    </style>
</head>

<body>
<!-- Sticky Container -->

    
    <div class="sticky-container">
    <!-- Rest of the button rows are initially hidden -->
    <div id="buttonSections" style="display: none;">
    
    
        <br>
        <div id="zipcode-section" class="button-row">
            <label for="zipcodeInput">Enter Zipcode:</label>
            <input type="text" id="zipcodeInput" placeholder="Enter zipcode" class="button-column"><button id="fetchCoordinatesButton" class="button-column">GO</button>
            <button id="instructionsButton" class="button-column">Instructions</button>
        </div>
    
        
        <div class="button-row">
            <div class="button-column">
                <div class="column-header">Table Display/Config:</div>
                <button id="toggleButton" class="button">Wind/Clouds</button>
                <button id="toggleTemperatureButton" class="button">Temperature</button>
                <button id="editThresholdsButton" class="button">Wind Speed Colors</button>
            </div>
        <br>
            <div class="button-column">
                <div class="column-header">View Options:</div>
                
                <button id="toggleDaylightButton" class="button">Show All Hours</button>
                <button id="toggleHighAltitudeButton" class="button">High Altitude</button>
                <button id="additionalVariablesButton" class="button">Additional Variables</button>
<br>
                <div class="button-column">
                    <div class="column-header">Analysis Options:</div>
                <button id="bestDaysButton" class="button" disabled>Best Hours</button>
                <button id="checkWindShearButton" class="button">Enable Wind Shear</button>
            </div></div>
            <div id="configPopup" class="config-popup" style="display: none;">
                <div class="config-content">
                    <label for="blueThreshold">Low Speed - Blue (mph)</label>
                    <input type="number" id="blueThreshold" value="7" min="0" /><br />
                    <label for="greenThreshold">Moderate Speed - Green (mph)</label>
                    <input type="number" id="greenThreshold" value="12" min="1" /><br />
                    <label for="redThreshold">High Speed - Red (mph)</label>
                    <input type="number" id="redThreshold" value="20" min="2" /><br />
                    <button id="submitThresholds">Submit</button>
                </div>
        </div>
        <div id="bestDaysPopup" class="config-popup" style="display: none;">
            <div class="config-content">
                <label for="bestWindSpeed">Max Wind Speed</label>
                <input type="number" id="bestWindSpeed" value="15" min="0" /><br />
                <button id="applyBestDaysButton">Apply</button>
        
            </div>
        </div>
    </div>
        <!-- Rest of the HTML content... -->
    
    </div></div>

        
        <!-- Edit Button (New) -->
        <button id="editButton" class="button-column">Toolbar</button>
</div>

        <!-- ICON Table -->
        



        </div>


        <table id="icon-table">
            <!-- The table will be populated by JavaScript -->
        </table>
        <br>
        <br>
        <!-- GFS Table -->
        <table id="gfs-table">
            <!-- The table will be populated by JavaScript -->
        </table>
        <!-- OpenMeteo Table -->
<br><br>





    </div>


    <script>

        let highAltitudeVisible = false;
        let windShearEnabled = true;
    
    let additionalVariablesEnabled=true;
        
        const highPressureAltitudes = [400, 500, 600, 700, 800]; // hPa values to be toggled

    const editButton = document.getElementById('editButton');
    const buttonSections = document.getElementById('buttonSections');

    
    // Listen for click events on the "Edit" button
    editButton.addEventListener('click', function () {
            // Toggle visibility state
            if (buttonSections.style.display === 'none') {
                buttonSections.style.display = 'block';    // Show the buttons
                editButton.textContent = 'Collapse';       // Update the button text to "Collapse"
            } else {
                buttonSections.style.display = 'none';     // Hide the buttons
                editButton.textContent = 'Toolbar';           // Reset the button text to "Edit"
            }
        });
        document.getElementById('toggleHighAltitudeButton').addEventListener('click', function () {
            // Toggle the flag
            highAltitudeVisible = !highAltitudeVisible;

            // Optionally, update button text or styling to reflect the state
            this.textContent = highAltitudeVisible ? 'Hide High Altitude' : 'Show High Altitude';
            fetchAllModelsData();
        });
        document.getElementById('checkWindShearButton').addEventListener('click', function () {
                console.log("Wind shear button clicked");
                windShearEnabled = !windShearEnabled;
                localStorage.setItem('windShearEnabled', windShearEnabled);

                console.log(windShearEnabled);
                const button = this; // 'this' refers to the button element in a regular function.

                // Always display "Loading..." text and disable the button while processing
                button.textContent = 'Loading...';
            

            
                fetchAllModelsData();
                if (windShearEnabled == true) { button.textContent = 'Disable Wind Shear'; }
                else (button.textContent = 'Enable Wind Shear' )
            
            });
        function fillTableWithTemperature(table, weatherData) {
                console.log('fillTableWithTemperature');
                const model = table.dataset.model; // Use the model attribute to customize the table for different data sources
                let tableHtml = '<tr>' + table.getElementsByTagName('tr')[0].innerHTML + '</tr>'; // Reuse the header rows for consistency

                const altitudeLevels = [2, 80, 1000, 180, 975, 950, 925, 900, 850, 800, 700, 600, 500, 400].reverse(); // Should match your data's altitude levels

                // Use the weatherData object to fill temperature data
                altitudeLevels.forEach(hPa => {
                    const temperatureKey = `temperature_${hPa}hPa`; // Must match the key used in your weatherData object for temperatures at different altitudes

                    if (weatherData.hourly.hasOwnProperty(temperatureKey)) {
                        // Convert hPa to feet for display
                        const displayAltitude = `${hPaToFeet(hPa)} ft`;

                        tableHtml += `<tr><th class="sticky-header">${displayAltitude}</th>`;

                        // Add temperature data cells
                        weatherData.hourly[temperatureKey].forEach(temp => {
                            const { backgroundColor, textColor } = getTemperatureColor(temp); // Get the color based on the temperature
                            tableHtml += `<td class="data-cell" style="background-color: ${backgroundColor}; color: ${textColor};">${Math.round(temp)}</td>`; // Display temperature with Fahrenheit symbol and gradient color
                        });

                        tableHtml += '</tr>';
                    }
                });

                table.innerHTML = tableHtml; // Update the table's HTML with the new rows
                table.dataset.showing = 'temperature'; // Update data attribute to indicate current data being shown
                // Disable all buttons except "Wind/Clouds" and "Temperature"
                toggleHighAltitude();
            toggleDaylightHours();
            disableButtonsExcept(['toggleButton', 'toggleTemperatureButton']);
        }
            function getTemperatureColor(temperature) {
                console.log('getTemperatureColor');
                    let percentage;
                    let backgroundColorRGB;
                    let textColor = 'black'; // Default text color

                    if (temperature >= 100) {
                        backgroundColorRGB = colors.maroon;
                    } else if (temperature >= 85) {
                        percentage = (temperature - 85) / (100 - 85);
                        backgroundColorRGB = interpolateColorRGB('red', 'maroon', percentage);
                    } else if (temperature >= 70) {
                        percentage = (temperature - 70) / (85 - 70);
                        backgroundColorRGB = interpolateColorRGB('blue', 'red', percentage);
                    } else if (temperature >= 40) {
                        percentage = (temperature - 40) / (70 - 40);
                        backgroundColorRGB = interpolateColorRGB('lightblue', 'blue', percentage);
                    } else if (temperature <= 32) {
                        backgroundColorRGB = colors.white;
                    } else { // Temperatures between 32 and 40
                        percentage = (temperature - 32) / (40 - 32);
                        backgroundColorRGB = interpolateColorRGB('white', 'lightblue', percentage);
                    }

                    // Set text color to white if background is dark
                    if (isColorDark(backgroundColorRGB.r, backgroundColorRGB.g, backgroundColorRGB.b)) {
                        textColor = 'white';
                    }

                    // Return the color in CSS rgb() format
                    const backgroundColor = `rgb(${backgroundColorRGB.r}, ${backgroundColorRGB.g}, ${backgroundColorRGB.b})`;
                    return { backgroundColor, textColor };
                }
                document.getElementById('instructionsButton').addEventListener('click', function () {
                        window.open('https://scottypres.github.io/instructions.html', '_blank');
                    });
        function displaywindshear() {
             console.log('checkwindshear');
                
        
                

            // Select all tables that end in '-table', such as 'icon-table', 'gfs-table', etc.
            console.log("Wind shear check starting...");
            const tables = document.querySelectorAll('table[id$="-table"]');
                    tables.forEach(table => {
                
                console.log(`Checking wind shear for table with ID: ${table.id}`); // Log which table is being checked

                // Get all the rows (tr elements) of the current table, excluding the header row
                const rows = table.querySelectorAll('tr:not(:first-child)');
                console.log(`${table.id} has ${rows.length} data rows available for wind shear detection.`);
                const rowCount = rows.length;

                // Ensure only the last 5 rows are considered
                const startRow = Math.max(rowCount - 12, 0);
                // Iterate through each row, but not the last row since there's no row below it
                 for (let rowIndex = startRow; rowIndex < rows.length - 1; rowIndex++) {
                    const currentRow = rows[rowIndex];
                    const nextRow = rows[rowIndex + 1];

                    // Get all cells within the current row that contain wind speed and direction data
                    const currentRowWindCells = currentRow.querySelectorAll('td[data-wind-speed][data-wind-direction]');

                    // Get all cells within the next row that contain wind speed and direction data
                    const nextRowWindCells = nextRow.querySelectorAll('td[data-wind-speed][data-wind-direction]');

                    // Only compare cells if the next row has the same number of wind data cells
                    if (currentRowWindCells.length === nextRowWindCells.length) {
                        // Compare each cell from the current row to the corresponding cell in the next row
                        currentRowWindCells.forEach((cell, cellIndex) => {
                            const currentWindSpeed = parseFloat(cell.dataset.windSpeed);
                            const currentWindDirection = parseFloat(cell.dataset.windDirection);

                            const nextCell = nextRowWindCells[cellIndex];
                            const nextWindSpeed = parseFloat(nextCell.dataset.windSpeed);
                            const nextWindDirection = parseFloat(nextCell.dataset.windDirection);

                            // Log the wind speeds and directions being compared for shear
                            //console.log(`Row: ${rowIndex + 1}, Column: ${cellIndex + 1}, Current Wind Speed: ${currentWindSpeed}, Next Wind Speed: ${nextWindSpeed}`);
                            // console.log(`Row: ${rowIndex + 1}, Column: ${cellIndex + 1}, Current Wind Direction: ${currentWindDirection}, Next Wind Direction: ${nextWindDirection}`);

                            // Check if the difference between current and next wind speed exceeds the threshold and check wind direction difference
                            if (Math.abs(currentWindSpeed - nextWindSpeed) > 9 || Math.abs(currentWindDirection - nextWindDirection) > 90) {
                                // Apply the "shear-detected" class to current and corresponding cell in the next row
                                cell.classList.add('shear-detected');
                                nextCell.classList.add('shear-detected');
                                //console.log(`SHEAR DETECTED ${table.id} Column: ${cellIndex + 1}`);
                                // Log that wind shear was detected between the two cells
                                // console.log(`Wind shear detected at Row: ${rowIndex + 1}, Column: ${cellIndex + 1}`);
                            }
                        });
                    }
                }
            });

             console.log("Wind shear check completed.");
                    
                    
                
        }

        function removeWindShearStyles() {
            console.log('removeWindShearStyles');
            document.querySelectorAll('.shear-detected').forEach(cell => {
                cell.classList.remove('shear-detected');
            });
        }
        function toggleHighAltitude() {
            console.log('toggleHighAltitude');
            if (!highAltitudeVisible) {  // Check if the flag indicates altitude should be hidden
                // console.log('Hiding high altitude rows');
                const tables = document.querySelectorAll('table[id$="-table"]');
                tables.forEach(table => {
                    const rows = table.getElementsByTagName('tr');
                    // Skip the header row by starting the loop at index 1
                    for (let i = 1; i < rows.length; i++) {
                        const altitudeInFeet = rows[i].cells[0].innerText.replace(' ft', '');
                        if (parseInt(altitudeInFeet) > 5000) {
                            rows[i].style.display = 'none'; // Hide the row
                        }
                    }
                });
            } else {
                // console.log('Showing high altitude rows');
                const tables = document.querySelectorAll('table[id$="-table"]');
                tables.forEach(table => {
                    const rows = table.getElementsByTagName('tr');
                    // Skip the header row by starting the loop at index 1
                    for (let i = 1; i < rows.length; i++) {
                        const altitudeInFeet = rows[i].cells[0].innerText.replace(' ft', '');
                        if (parseInt(altitudeInFeet) > 5000) {
                            rows[i].style.display = ''; // Show the row
                        }
                    }
                });
            }
        }
        let daylightHoursShown = true;
        let userLocation = {
            latitude: 26.4187,   // Use a default latitude or prompt the user to enter a valid one.
            longitude: 81.4173,  // Use a default longitude or prompt the user to enter a valid one.
        };
        
        document.getElementById('additionalVariablesButton').addEventListener('click', () => {
            additionalVariablesEnabled = !additionalVariablesEnabled; // Toggle the boolean value
            // console.log("Additional Variables Enabled:", additionalVariablesEnabled);
            setCookie('additionalVariablesEnabled', additionalVariablesEnabled, 365);
            // Update button text to reflect the current state
            document.getElementById('additionalVariablesButton').textContent =
                additionalVariablesEnabled ? "Toggle Additional Variables" : "Toggle Additional Variables";
            fetchAllModelsData();
            // Add any other code that should run when the toggle occurs
        });

        // Initialize global threshold variables
        lowWindThreshold = 7;
        medWindThreshold = 15;
        highWindThreshold = 20;
        // Declare this at the top to store the initial view

        let globalWeatherData = {};
        let bestWindSpeedThreshold = 15;

        document.getElementById('toggleDaylightButton').addEventListener('click', function () {
                daylightHoursShown = !daylightHoursShown;
                this.textContent = daylightHoursShown ? 'Daylight' : 'Show All Hours';
                setCookie('daylightHoursShown', daylightHoursShown ? 'true' : 'false', 365); // Save the state in a cookie
                fetchAllModelsData();
            });

        function toggleDaylightHours() {
                const tables = document.querySelectorAll('table[id$="-table"]'); // Select all tables

                // Iterate over each table
                tables.forEach(table => {
                    const headerCells = table.querySelectorAll('tr:first-child th:not(:first-child)'); // Header cells, excluding the first sticky column
                    console.log('daylight hours shown');
                
                    headerCells.forEach((cell, index) => {
                        // Check if the header cell has the 'daylight' class
                        const isDaylight = cell.classList.contains('daylight');

                        // Instead of removing cells, we toggle their visibility
                        if (daylightHoursShown && !isDaylight) {
                            // If daylight hours should be shown but the cell is not marked as daylight, hide it
                            cell.style.display = 'none';
                        } else {
                            // Otherwise, show the cell
                            cell.style.display = '';
                        }

                        // Apply the same display style to the corresponding data cells in each row
                        table.querySelectorAll(`tr:not(:first-child) td:nth-child(${index + 2})`).forEach(dataCell => {
                            dataCell.style.display = cell.style.display; // Match the display style of the header cell
                        });
                    });
                    console.log(daylightHoursShown);
                });

                
                
            }


    document.getElementById('bestDaysButton').addEventListener('click', function () {
        const isPopupVisible = document.getElementById('bestDaysPopup').style.display === 'flex';
      
            // Show the popup
            document.getElementById('bestDaysPopup').style.display = 'flex';
            // Disable buttons other than 'applyBestDaysButton' and 'fetchCoordinatesButton'
            toggleButtonsDisabledState(true, ['applyBestDaysButton', 'editButton']);
        }
    );

    
    let showingBestHours = false;
       ;
        function resetTables() {
            console.log('resetTables');
            // Loop over each model to create the tables again using the stored data
            //  console.log('resetTables');
            Object.keys(globalWeatherData).forEach(model => {
                const tableId = `${model.toLowerCase()}-table`;
                createTable(tableId, globalWeatherData[model], model);
            });
            // After resetting the tables, update the toggle button text to reflect the content shown in the tables

            initialTableSetup();
        }

        // Event listener to handle when the user clicks the "Apply" button in the Best Days popup
        document.getElementById('applyBestDaysButton').addEventListener('click', function () {
                const bestDaysPopup = document.getElementById('bestDaysPopup');
                const applyBestDaysButton = this; // "this" refers to the 'applyBestDaysButton'
                const bestDaysButton = document.getElementById('bestDaysButton'); // Assuming this is the ID of your "Best Days/Reset Best Hours" button

                if (!bestDaysPopup.style.display || bestDaysPopup.style.display === 'none') {
                    // Show the popup
                    bestDaysPopup.style.display = 'flex';
                } else {
                    // Since the popup is visible, apply the filter
                    filterBestDaysColumns();
                    
                    applyBestDaysButton.textContent = 'Apply';
                    bestDaysButton.textContent = 'Reset Best Hours'; // Change the button text to 'Reset Best Hours'
                    bestDaysPopup.style.display = 'none';
                }
                toggleButtonsDisabledState(false, ['editButton']);
            });
    document.getElementById('bestDaysButton').addEventListener('click', function () {
    if (this.textContent === 'Reset Best Hours') {
        // Reset the tables
        resetTables();

        // Change the button text back to 'Best Hours'
        this.textContent = 'Best Hours';

        // Hide the popup if it's visible
        document.getElementById('bestDaysPopup').style.display = 'none';
    }
});
        function filterBestDaysColumns() {
            console.log('filterBestDaysColumns');
            // Threshold in mph
            const bestWindSpeedThreshold = parseFloat(document.getElementById('bestWindSpeed').value);

            // Get tables containing wind speeds
            const tables = document.querySelectorAll('table[id$="-table"]');

            tables.forEach(table => {
                // Get all header cells (ignoring the first row which contains model names)
                const headers = table.querySelectorAll('tr:first-child th:not(:first-child)');
                // Get all rows to access speed values at specified altitudes
                const rows = table.querySelectorAll('tr:not(:first-child)');

                // Determine which rows correspond to altitudes 33, 262, and 361 ft
                const targetAltitudeRows = [...rows].filter(row => {
                    const altitudeText = row.cells[0].innerText.trim();
                    const altitude = parseInt(altitudeText.replace(' ft', ''), 10);
                    return [33, 262, 361].includes(altitude);
                });

                // Keep track of the last known day of week text to compare days


                // Iterate over each column (time slot) and check if values exceed the threshold
                headers.forEach((header, columnIndex) => {
                    // Extract day of week from the header cell, assuming the format is MM/DD\nDay\nHH\nAM/PM
                    const dayOfWeek = header.innerText.trim().split('\n')[1]; // Day of week is on the second line



                    // Check whether any of the wind speeds exceed the threshold
                    let columnOverThreshold = targetAltitudeRows.some(row => {
                        const windSpeedText = row.cells[columnIndex + 1].innerText.trim();
                        const windSpeed = parseFloat(windSpeedText);
                        return windSpeed > bestWindSpeedThreshold;
                    });

                    // Hide the whole column if the threshold is exceeded
                    if (columnOverThreshold) {
                        headers[columnIndex].style.display = 'none'; // Hide header cell
                        rows.forEach(row => {
                            row.cells[columnIndex + 1].style.display = 'none'; // Hide data cell
                        });
                    } else {
                        // Ensure the column is visible if it does not exceed the threshold
                        headers[columnIndex].style.display = ''; // Show header cell
                        rows.forEach(row => {
                            row.cells[columnIndex + 1].style.display = ''; // Show data cell
                        });
                    }
                });
                  headers.forEach((header, columnIndex) => {
                    if (!header.classList.contains('daylight')) {
                        header.style.display = 'none'; // Hide header cell with no 'daylight' class
                        rows.forEach(row => {
                            row.cells[columnIndex + 1].style.display = 'none'; // Hide associated data cells
                        });
                    }
                });
            });
        }

        // After tables have been generated, enable the "Best Days" button
        function enableBestDaysButton() {
            const bestDaysButton = document.getElementById('bestDaysButton');
            if (bestDaysButton) {
                bestDaysButton.disabled = false; // Enable the button
            }
        }
       function getWindArrowClass(degrees) {
            // Ensure degrees are within 0-359 and add 180 degrees to flip the arrow
            degrees = (degrees + 180) % 360;
            // Get the nearest multiple of 22.5
            const closestMultiple = Math.round(degrees / 22.5) * 22.5;
            // Create the class name by replacing '.' with '-' to match CSS class naming
            const classNameDegrees = closestMultiple.toString().replace('.', '-');
            return 'wind-arrow rotate-' + classNameDegrees;
        }
        function initialTableSetup() {
            console.log('Initial Table Setup');
            if (!isUpdatingTables) {
                Object.keys(globalWeatherData).forEach(model => {
                    const tableId = `${model.toLowerCase()}-table`;
                    const dataTable = document.getElementById(tableId);
                    fillTableWithWindSpeed(dataTable, globalWeatherData[model]); // Show winds data first
                    dataTable.dataset.showing = 'winds'; // Indicate that winds are being shown
                })
            };
            // toggleDaylightHours();
            submitThresholdsAndRepaint();
        }
        function showConfigPopup() {
                document.getElementById('configPopup').style.display = 'flex';

                // Now, include the 'editButton' ID in the list of buttons to be excluded from disabling
                toggleButtonsDisabledState(true, ['submitThresholds', 'fetchCoordinatesButton', 'editButton']);
            }
            
        // Fetch data for each model
        const baseUrls = {
            //openMeteo: 'https://api.open-meteo.com/v1/forecast',
            gfs: 'https://api.open-meteo.com/v1/gfs',
            icon: 'https://api.open-meteo.com/v1/dwd-icon'
        };
        //fetchAllModelsData();
        document.getElementById('editThresholdsButton').addEventListener('click', showConfigPopup); // assume editThresholdsButton is the ID of the button to show the popup
        function submitThresholdsAndRepaint() {
            // Get the threshold values from the input fields
            const blueThreshold = parseInt(document.getElementById('blueThreshold').value, 10);
            const greenThreshold = parseInt(document.getElementById('greenThreshold').value, 10);
            const redThreshold = parseInt(document.getElementById('redThreshold').value, 10);

            // Store them in cookies
            setCookie('blueThreshold', blueThreshold, 365);
            setCookie('greenThreshold', greenThreshold, 365);
            setCookie('redThreshold', redThreshold, 365);

            // Repaint the graph
            repaintGraphsWithNewThresholds(blueThreshold, greenThreshold, redThreshold);

            // Hide the config popup
            document.getElementById('configPopup').style.display = 'none';
            
         toggleButtonsDisabledState(false, ['editButton']);
        }
    function toggleButtonsDisabledState(disable, excludeIds = []) {
        const allButtons = document.querySelectorAll('button');
        allButtons.forEach(button => {
            if (!excludeIds.includes(button.id)) {
                button.disabled = disable; // Disable or enable buttons based on the 'disable' boolean
                button.style.opacity = disable ? '0.5' : '1'; // Toggle opacity
            }
        });
    }

    function showConfigPopup() {
        document.getElementById('configPopup').style.display = 'flex';

        // Disable buttons other than 'submitThresholds' and 'fetchCoordinatesButton'
        toggleButtonsDisabledState(true, ['submitThresholds', 'editButton']);
    }

    document.getElementById('submitThresholds').addEventListener('click', submitThresholdsAndRepaint);
        function repaintGraphsWithNewThresholds(low, med, high) {
            // Assume these are the names of three different tables you have
            lowWindThreshold = low;
            medWindThreshold = med;
            highWindThreshold = high;

            const tableIds = ['icon-table', 'gfs-table']; // Add other table IDs as needed
            tableIds.forEach(tableId => {
                const table = document.getElementById(tableId);
                if (table.dataset.showing === 'winds') {
                    fillTableWithWindSpeed(table, globalWeatherData[table.dataset.model]);
                }
            });
            
        }
        function hPaToFeet(hPa) {
            const conversionTable = {
                1000: 110,
                975: 320,
                950: 500,
                925: 800,
                900: 1000,
                850: 1500,
                800: 1900,
                700: 3000,
                600: 4200,
                500: 5600,
                400: 7200
            };

            const meters = conversionTable[hPa];
            const feet = meters * 3.28084; // Convert meters to feet
            return Math.round(feet);
        }

        document.querySelectorAll('table[id$="-table"]').forEach(table => {
            table.dataset.showing = 'winds'; // Start with winds data shown
        });
        document.getElementById('fetchCoordinatesButton').addEventListener('click', () => {
                const zipcode = document.getElementById('zipcodeInput').value.trim();
                if (zipcode) {
                    handleZipcodeFetch(zipcode);

                    // Collapse the button sections after initiating the fetch
                    buttonSections.style.display = 'none'; // Hide the buttons
                    editButton.textContent = 'Toolbar'; // Reset the button text to "Edit"
                } else {
                    alert('Please enter a valid zipcode.');
                }
            });
        let isUpdatingTables = false;
        async function fetchAllModelsData() {
            if (isUpdatingTables) return;
            isUpdatingTables = true;
            console.log("Inside fetchAllModelsData before Promise.all", new Date().toISOString());
            try {
                // Await all fetches to be completed using Promise.all
                await Promise.all(Object.entries(baseUrls).map(async ([model, baseUrl]) => {
                    console.log(`Fetching data for model "${model}"`, new Date().toISOString());
                    await checkAndFetchData(baseUrl, model);
                }));

                

                // Now that we have all data, setup the tables and perform shear checks
                initialTableSetup();

            } catch (error) {
                console.error('Error fetching data for all models:', error);
            }
            isUpdatingTables = false;
        }

        // Fetch data for each model by calling the new fetchAllModelsData function
        //fetchAllModelsData();

        let commonParameters = [];

        async function getCoordinatesByZipcode(zipcode) {
            console.log("getCoordinatesByZipcode");
            
            //console.log("getCoordinatesByZipcode called", new Date().toISOString());
            const zipApiUrl = `https://api.zippopotam.us/us/${zipcode}`;
            // console.log("getCoordinatesByZipcode start", new Date().toISOString());
            try {
                const response = await fetch(zipApiUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                if (data && data.places.length > 0) {
                    // Update the global location variable
                    userLocation = {
                        latitude: parseFloat(data.places[0].latitude),
                        longitude: parseFloat(data.places[0].longitude)
                    };
                    //console.log('Coordinates:', userLocation);
                    setCookie('zipcode', zipcode, 365); // Save for 365 days
                    // console.log('zip cookie saved');
                    // Now call the API with these coordinates for each model and update the table with new data
                    for (const model of Object.keys(baseUrls)) {
                        await checkAndFetchData(baseUrls[model], model);
                    }
                    initialTableSetup(); // Refresh the table setup


                } else {
                    alert('No coordinates found for the provided zipcode.');
                }
            } catch (error) {
                console.error('Failed to fetch coordinates:', error);
                alert('Failed to get coordinates. Please check the zipcode and try again.');
            }

            console.log("getCoordinatesByZipcode end", new Date().toISOString());


        };

        async function checkAndFetchData(baseUrl, model) {
            console.log("checkAndFetchData");
            // console.log(`checkAndFetchData called for model ${model}`, new Date().toISOString());
            const dailyParameters = [
                'weather_code',
                'temperature_2m_max',
                'temperature_2m_min',
                'apparent_temperature_max',
                'apparent_temperature_min',
                'sunrise',
                'sunset',
                'uv_index_max',
                'precipitation_sum'
            ].join(',');



            const units = '&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto';
            let additionalParameters = ''; // Initialize additional parameters string


            // Check the model to determine the correct forecast_days parameter
            if (model.toLowerCase() === 'openmeteo') {
                additionalParameters += '&forecast_days=14'; // 14-day forecast for OpenMeteo
            } else if (model.toLowerCase() === 'icon') {
                additionalParameters += '&forecast_days=7' ; // 7-day forecast for ICON
            }
            if (model.toLowerCase() === 'gfs') {
                additionalParameters += '&forecast_days=14'; // 14-day forecast for OpenMeteo
            }
            const zipcode = document.getElementById('zipcodeInput').value.trim();
            const lastApiCallKey = `lastApiCall_${model}_${zipcode}`;
            const now = Date.now();
            const cacheDuration = 15 * 60 * 1000; // 15 minutes in milliseconds
            const lastApiCallData = localStorage.getItem(lastApiCallKey);
            let shouldFetchData = true;

            // Check if we have cached data for this model and zipcode
            if (lastApiCallData) {
                const cachedData = JSON.parse(lastApiCallData);

                // Check if the cached data is still valid
                if (cachedData.zipcode === zipcode && now - cachedData.timestamp < cacheDuration) {
                    // console.log(`Using cached data for model "${model}"`, new Date().toISOString());
                    globalWeatherData[model] = cachedData.data;
                    createTable(`${model.toLowerCase()}-table`, cachedData.data, model);
                    shouldFetchData = false;
                }
            }

            // Fetch new data if necessary
            if (shouldFetchData) {

                if (model.toLowerCase() === 'icon') {
                    commonParameters = [
                        'temperature_2m', 'temperature_80m', 'temperature_180m',
                        'weather_code', 'relative_humidity_2m',
                        'dew_point_2m',
                        'cloud_cover',
                        'cloud_cover_low',
                        'cloud_cover_mid',
                        'cloud_cover_high',
                        'cloud_cover_1000hPa',
                        'cloud_cover_975hPa',
                        'cloud_cover_950hPa',
                        'cloud_cover_925hPa',
                        'cloud_cover_900hPa',
                        'cloud_cover_850hPa',
                        'cloud_cover_800hPa',
                        'cloud_cover_700hPa',
                        'cloud_cover_600hPa',
                        'cloud_cover_500hPa',
                        'cloud_cover_400hPa',
                        // Add new variables below
                        'wind_speed_10m',
                        'wind_speed_80m',
                        'wind_speed_180m', 'wind_gusts_10m',
                        'wind_direction_10m',
                        'wind_direction_80m',
                        'wind_direction_180m',
                        'temperature_1000hPa',
                        'temperature_975hPa',
                        'temperature_950hPa',
                        'temperature_925hPa',
                        'temperature_900hPa',
                        'temperature_850hPa',
                        'temperature_800hPa',
                        'temperature_700hPa',
                        'temperature_600hPa',
                        'temperature_500hPa',
                        'temperature_400hPa',

                        'windspeed_1000hPa',
                        'windspeed_975hPa',
                        'windspeed_950hPa',
                        'windspeed_925hPa',
                        'windspeed_900hPa',
                        'windspeed_850hPa',
                        'windspeed_800hPa',
                        'windspeed_700hPa',
                        'windspeed_600hPa',
                        'windspeed_500hPa',
                        'windspeed_400hPa',
                        'winddirection_1000hPa',
                        'winddirection_975hPa',
                        'winddirection_950hPa',
                        'winddirection_925hPa',
                        'winddirection_900hPa',
                        'winddirection_850hPa',
                        'winddirection_800hPa',
                        'winddirection_700hPa',
                        'winddirection_600hPa',
                        'winddirection_500hPa',
                        'winddirection_400hPa',
                        'cape',
                        'is_day'
                    ].join(',');
                }
                if (model.toLowerCase() === 'gfs' || model.toLowerCase() === 'openmeteo') {
                    commonParameters = [
                        'temperature_2m', 'temperature_80m', 'temperature_180m',
                        'weather_code', 'relative_humidity_2m',
                        'dew_point_2m',
                        'cloud_cover',
                        'cloud_cover_low',
                        'cloud_cover_mid',
                        'cloud_cover_high',
                        'cloud_cover_1000hPa',
                        'cloud_cover_975hPa',
                        'cloud_cover_950hPa',
                        'cloud_cover_925hPa',
                        'cloud_cover_900hPa',
                        'cloud_cover_850hPa',
                        'cloud_cover_800hPa',
                        'cloud_cover_700hPa',
                        'cloud_cover_600hPa',
                        'cloud_cover_500hPa',
                        'cloud_cover_400hPa',
                        // Add new variables below
                        'wind_speed_10m',
                        'wind_speed_80m',
                        'wind_speed_180m', 'wind_gusts_10m',
                        'wind_direction_10m',
                        'wind_direction_80m',
                        'wind_direction_180m',
                        'temperature_1000hPa',
                        'temperature_975hPa',
                        'temperature_950hPa',
                        'temperature_925hPa',
                        'temperature_900hPa',
                        'temperature_850hPa',
                        'temperature_800hPa',
                        'temperature_700hPa',
                        'temperature_600hPa',
                        'temperature_500hPa',
                        'temperature_400hPa',
                        'windspeed_1000hPa',
                        'windspeed_975hPa',
                        'windspeed_950hPa',
                        'windspeed_925hPa',
                        'windspeed_900hPa',
                        'windspeed_850hPa',
                        'windspeed_800hPa',
                        'windspeed_700hPa',
                        'windspeed_600hPa',
                        'windspeed_500hPa',
                        'windspeed_400hPa',
                        'winddirection_1000hPa',
                        'winddirection_975hPa',
                        'winddirection_950hPa',
                        'winddirection_925hPa',
                        'winddirection_900hPa',
                        'winddirection_850hPa',
                        'winddirection_800hPa',
                        'winddirection_700hPa',
                        'winddirection_600hPa',
                        'winddirection_500hPa',
                        'winddirection_400hPa',
                        'cape',
                        'is_day',
                        'precipitation_probability'
                    ].join(',');
                }





                const requestUrl = `${baseUrl}?latitude=${userLocation.latitude}&longitude=${userLocation.longitude}&hourly=${commonParameters}&daily=${dailyParameters}${units}${additionalParameters}`;

                try {
                    console.log('fetching new data');
                    // Request data from the weather API using the assembled URL
                    const response = await fetch(requestUrl);

                    // If the response is not okay, throw an error
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    // Parse the response as JSON
                    const weatherData = await response.json();

                    // Cache the new API data
                    localStorage.setItem(lastApiCallKey, JSON.stringify({
                        timestamp: now,
                        data: weatherData,
                        zipcode: zipcode
                    }));

                    // Populate the respective table with the fetched data
                    createTable(`${model.toLowerCase()}-table`, weatherData, model);

                    // Store the fetched data globally
                    globalWeatherData[model] = weatherData;

                    console.log(`Data fetched successfully for model ${model}`);
                } catch (error) {
                    // Log the error if fetching the data fails
                    console.error(`Failed to fetch data for model ${model}`, error);
                    // Optionally, handle the error in the UI
                }
            }

            // console.log(`checkAndFetchData finished for model ${model}`, new Date().toISOString());
        }



        function setCookie(name, value, days) {
            const d = new Date();
            d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
            const expires = `expires=${d.toUTCString()}`;
            document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)};${expires};path=/`;
        }

        function getCookie(name) {
            const cname = `${encodeURIComponent(name)}=`;
            const decodedCookie = decodeURIComponent(document.cookie);
            const ca = decodedCookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(cname) === 0) {
                    return c.substring(cname.length, c.length);
                }
            }
            return "";
        }





        window.onload = function () {
            console.log("window.onload");
            // Automatically click the edit button when the page loads for the first time
    const editButton = document.getElementById('editButton');
    if (editButton) {
        editButton.click();
    }

            // Check for saved wind shear enabled state
            const savedWindShearEnabled = localStorage.getItem('windShearEnabled');
            if (savedWindShearEnabled !== null) {
                // If we have a saved value, use it to set the windShearEnabled flag
                windShearEnabled = (savedWindShearEnabled === 'true');
            } else {
                // Initialize with a default value (e.g., false) and save it to localStorage
                windShearEnabled = false;
                localStorage.setItem('windShearEnabled', windShearEnabled);
            }
             document.getElementById('checkWindShearButton').textContent =
                windShearEnabled ? 'Disable Wind Shear' : 'Enable Wind Shear';
            // Get threshold values from cookies, if they exist
            const blueThreshold = getCookie('blueThreshold');
            const greenThreshold = getCookie('greenThreshold');
            const redThreshold = getCookie('redThreshold');
            
            const additionalVariablesCookie = getCookie('additionalVariablesEnabled');
            if (additionalVariablesCookie) {
                // If we have a saved value, use it to set the additionalVariablesEnabled flag
                additionalVariablesEnabled = additionalVariablesCookie === 'true';
            } else {
                // If no value is saved, use the default value (true)
                let additionalVariablesEnabled = true;
                // Optionally set the cookie with the default value for future visits
                setCookie('additionalVariablesEnabled', additionalVariablesEnabled, 365);
            }
            // Update threshold inputs with cookie values
            if (blueThreshold) document.getElementById('blueThreshold').value = blueThreshold;
            if (greenThreshold) document.getElementById('greenThreshold').value = greenThreshold;
            if (redThreshold) document.getElementById('redThreshold').value = redThreshold;

            // Check for the presence of the zipcode cookie
            const savedZipcode = getCookie('zipcode');

            if (savedZipcode) {
                const zipcodeInput = document.getElementById('zipcodeInput');

                const fetchButton = document.getElementById('fetchCoordinatesButton');

                zipcodeInput.value = savedZipcode;
                //   console.log("Zip cookie loaded");
                // Check if fetchCoordinatesButton has already a click event listener that fetches the weather
                // If not, manually call the handleZipcodeFetch(zipcode) function after a short delay to ensure any setup logic has completed
                setTimeout(function () {
                    fetchButton.click();
                }, 0);
            }
            const savedBestWindSpeed = getCookie('bestWindSpeed');

            if (savedBestWindSpeed) {
                // If we have a saved value, use it as the best wind speed threshold
                bestWindSpeedThreshold = parseFloat(savedBestWindSpeed);
            } else {
                // If no value is saved, use default value
                bestWindSpeedThreshold = 15;
            }

            // Update the value in the input field
            document.getElementById('bestWindSpeed').value = bestWindSpeedThreshold;
            document.getElementById('toggleTemperatureButton').addEventListener('click', () => {
                toggleTemperatureTables();
            });
            const daylightHoursCookie = getCookie('daylightHoursShown');
            if (daylightHoursCookie !== "") {
                daylightHoursShown = (daylightHoursCookie === 'true');
            } else {
                // If the cookie does not exist, use your initial default value
                daylightHoursShown = true;
            }
            // Set the initial button text
            document.getElementById('toggleDaylightButton').textContent = daylightHoursShown ? 'Daylight' : 'Show All Hours';
        };
        function toggleTemperatureTables() {
            console.log("toggleTemperatureTables");
                Object.keys(globalWeatherData).forEach(model => {
                    const tableId = `${model.toLowerCase()}-table`;
                    const dataTable = document.getElementById(tableId);

                    // Check the current state and toggle accordingly
                     if (dataTable.dataset.showing !== 'temperature') {
                        // Currently showing something other than temperature, switch to temperature
                        fillTableWithTemperature(dataTable, globalWeatherData[model]);
                        dataTable.dataset.showing = 'temperature'; // Indicate that temperature is being shown
                    } else {
                        // Currently showing temperature, switch to wind speed
                        fillTableWithWindSpeed(dataTable, globalWeatherData[model]);
                        dataTable.dataset.showing = 'winds'; // Indicate that winds are being shown
                    }
                });
            }
            document.getElementById('zipcodeInput').addEventListener('keyup', function (event) {
                    if (event.key === 'Enter' || event.keyCode === 13) {
                        // Call the function that fetches coordinates and updates the weather data
                        handleZipcodeSubmit();
                    }
                });

                function handleZipcodeSubmit() {
                    const zipcode = document.getElementById('zipcodeInput').value.trim();
                    if (zipcode) {
                        handleZipcodeFetch(zipcode);

                        // Collapse the button sections after initiating the fetch
                        buttonSections.style.display = 'none'; // Hide the buttons
                        editButton.textContent = 'Edit'; // Reset the button text to "Edit"
                    } else {
                        alert('Please enter a valid zipcode.');
                    }
                }
        async function handleZipcodeFetch(zipcode) {
            // Disable the button and recent search links to prevent multiple fetches
            document.getElementById('fetchCoordinatesButton').disabled = true;
            document.querySelectorAll('.recent-search').forEach(elem => elem.style.pointerEvents = 'none');

            // Fetch the coordinates and update the tables
            await getCoordinatesByZipcode(zipcode);
            // Re-enable the button and the recent search links
            document.getElementById('fetchCoordinatesButton').disabled = false;
            document.querySelectorAll('.recent-search').forEach(elem => elem.style.pointerEvents = '');
        }
        
    function addVerticalBordersBetweenDays() {
            // Select all tables that you want to apply the border to
            const tables = document.querySelectorAll('table');



        if (daylightHoursShown == false) {
            tables.forEach(table => {
                // Get all header cells in the first row
                const dayHeaders = table.querySelectorAll('tr:first-child th:not(:first-child)');

                // Loop through the header cells to check for "daylight" class transitions
                dayHeaders.forEach((headerCell, index) => {
                    const isDaylight = headerCell.classList.contains('daylight');
                    const prevHeader = dayHeaders[index - 1];
                    const nextHeader = dayHeaders[index + 1];

                    // If it's daylight and the previous header is not, apply a left border
                    if (isDaylight && (!prevHeader || !prevHeader.classList.contains('daylight'))) {
                        headerCell.style.borderLeft = '3px solid black';
                        table.querySelectorAll(`tr:not(:first-child) td:nth-child(${index + 2})`).forEach(cell => {
                            cell.style.borderLeft = '3px solid black';
                        });
                    }

                    // If it's daylight and the next header is not, apply a right border
                    if (isDaylight && (!nextHeader || !nextHeader.classList.contains('daylight'))) {
                        headerCell.style.borderRight = '3px solid black';
                        table.querySelectorAll(`tr:not(:first-child) td:nth-child(${index + 2})`).forEach(cell => {
                            cell.style.borderRight = '3px solid black';
                        });
                    }
                });
            });
        }

            if (daylightHoursShown==true){
            // Iterate over each table
            tables.forEach(table => {
                // Get all header cells in the first row that have 'data-day' attribute, excluding the very first cell
                const dayHeaders = table.querySelectorAll('tr:first-child th[data-day]:not(:first-child)');

                // Initialize variable to store the previous day
                let previousDay = null;

                // Iterate through headers to find day transitions
                dayHeaders.forEach((headerCell, index) => {
                    // Check if the cell is visible (not hidden due to daylight or altitudes toggle)
                    if (headerCell.style.display !== 'none') {
                        const currentDay = headerCell.getAttribute('data-day');

                        // Add border if the current day is different from the previous day and not the first cell
                        if (previousDay && currentDay !== previousDay) {
                            // Add a vertical border to the left side of the current header cell
                            headerCell.style.borderLeft = '3px solid black';
                            // Also apply the border to all cells in the same column below the header
                            table.querySelectorAll(`tr:not(:first-child) td:nth-child(${index + 2}):not([style*="display: none"])`).forEach(cell => {
                                // Check if the cell is visible (not hidden due to daylight or altitudes toggle)
                                if (cell.style.display !== 'none') {
                                    cell.style.borderLeft = '3px solid black';
                                }
                            });
                        }

                        // Update previousDay to the current day for the next iteration
                        previousDay = currentDay;
                    }
                });
            });
        }





        }
        function createTable(tableId, weatherData, model) {
            console.log('createTable');
            console.log(globalWeatherData);
            const altitudeLabels = [1000, 975, 950, 925, 900, 850, 800, 700, 600, 500, 400].reverse();
            const timestamps = weatherData.hourly.time;
            const dataTable = document.getElementById(tableId);


            let tableHtml = `<tr><th>${model.replace('Meteo', '<br>Meteo')}</th>`;
            let currentDay = null; // Variable to store the current day as you loop through the timestamps
            // Assuming that weatherData.hourly.is_day is an array with the same length as timestamps
            let isDayArray = weatherData.hourly.is_day;
            console.log(isDayArray);
            isDayArray = extendDaylightHours(isDayArray);
            console.log(isDayArray);
            
            timestamps.forEach((timestamp, index) => {
                const date = new Date(timestamp);
                const day = date.getDate();
                const month = date.getMonth() + 1;
                const dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'short' }).slice(0, 2); // Use first two letters
                const hour = date.getHours();
                const hour12 = hour % 12 || 12; // Convert to 12-hour format
                const ampm = hour >= 12 ? 'PM' : 'AM';
                // Determine if the timestamp corresponds to daylight using is_day array
                const isDaylight = isDayArray[index] === 1;
                const daylightClass = isDaylight ? 'daylight' : '';
                

                

                headerClass = '';
                    tableHtml += `<th class="column-header ${daylightClass}" data-day="${day}">
                    <span class="smalldate">${month}/${day}</span><br>
                    <span class="small-font">${dayOfWeek}</span><br>
                    <span class="small-font">${hour12}</span><br><span class="small-font">${ampm}</span>
                 </th>`;
                enableBestDaysButton();
            });


            tableHtml += '</tr>';

            // Add rows for each altitude
            altitudeLabels.forEach(hPa => {
                // Convert hPa to feet for the display label
                const feet = hPaToFeet(hPa);

                // Start the table row with the altitude label
                tableHtml += `<tr><th class="sticky-header">${feet} ft</th>`;

                // Presuming the weatherData variable holds your cloud cover data indexed by hPa, 
                // e.g., `cloud_cover_1000hPa`, `cloud_cover_975hPa`, etc.
                const cloudCoverKey = `cloud_cover_${hPa}hPa`;
                const allShearCells = document.querySelectorAll('.shear-detected');
                allShearCells.forEach(cell => {
                    cell.classList.remove('shear-detected');
                });
                // Check if the cloud cover data exists for this altitude level
                if (weatherData.hourly.hasOwnProperty(cloudCoverKey)) {
                    // Add a data cell for each time interval
                    weatherData.hourly[cloudCoverKey].forEach(cloudCover => {
                        // Calculate the background color based on cloud cover percentage
                        const bgColor = `rgba(0, 0, 0, ${cloudCover * 0.75 / 100})`;

                        // Append the data cell with styling for cloud cover
                        tableHtml += `<td class="grey-bg" style="background-color: ${bgColor}"></td>`;
                    });
                } else {
                    // If cloud cover data does not exist for this pressure altitude (hPa), span across all time intervals
                    tableHtml += `<td colspan="${weatherData.hourly.time.length}" class="data-cell">Data not available</td>`;
                    console.log('cloud cover data does not exist for this pressure');
                    console.log(cloudCoverKey);
                }

                // Close the table row
                tableHtml += '</tr>';
            });

            dataTable.innerHTML = tableHtml;




            dataTable.dataset.model = model;
            //console.log(`Listeners added for ${model} model`);
        }

        document.getElementById('toggleButton').addEventListener('click', toggleWindClouds);
        document.getElementById('toggleButton').textContent = 'Winds/Clouds'; // Default text
        function toggleWindClouds() {
            Object.keys(globalWeatherData).forEach(model => {
                const tableId = `${model.toLowerCase()}-table`;
                const dataTable = document.getElementById(tableId);
                const currentDisplay = dataTable.dataset.showing;

                if (currentDisplay === 'clouds') {
                    // Display wind data
                    fillTableWithWindSpeed(dataTable, globalWeatherData[model]);
                    dataTable.dataset.showing = 'winds';
                } else {
                    // Display cloud cover data
                    fillTableWithCloudCover(dataTable, globalWeatherData[model]);
                    dataTable.dataset.showing = 'clouds';
                }
            });


        }



        function extendDaylightHours(isDayArray) {
            console.log('extendDaylightHours');
                const transitions = [];

                // Step 1: Identify all transition indices
                for (let i = 1; i < isDayArray.length; i++) {
                    if (isDayArray[i] !== isDayArray[i - 1]) {
                        transitions.push(i);
                    }
                }

                // Step 2: Extend daylight by modifying the array at the transition points
                transitions.forEach(index => {
                    if (isDayArray[index] === 1) {
                        // Extend the daylight by setting the previous hour to 1 (morning transition)
                        isDayArray[index - 1] = 1;
                    } else {
                        // Extend the daylight by setting the next hour to 1 (evening transition)
                        // Check if the index is not the last element of the array
                        if (index < isDayArray.length) {
                            isDayArray[index] = 1;
                        }
                    }
                });

                return isDayArray;
            }


        function fillTableWithWindSpeed(table, weatherData) {
            //console.log(new Error('Stack trace for fillTableWithWindSpeed call').stack);
            let tableHtml = '<tr>' + table.getElementsByTagName('tr')[0].innerHTML + '</tr>';
            const altitudeLevels = [10, 80, 1000, 180, 975, 950, 925, 900, 850, 800, 700, 600, 500, 400].reverse(); // Order hPa values and feet values in descending order
            let gustRowAdded = false; // Flag to control the addition of the gust row
            altitudeLevels.forEach(alt => {
                let windSpeedKey, windDirectionKey;
                let displayAltitude; // Define a variable to hold our display altitude

                if (alt === 10 || alt === 80 || alt === 180) {
                    // Handle the specific feet values (10m, 80m, 180m are in meters, need conversion to feet)
                    const altInFeet = Math.round(alt * 3.28084); // Convert meters to feet, rounding to the nearest whole number
                    windSpeedKey = `wind_speed_${alt}m`;
                    windDirectionKey = `wind_direction_${alt}m`;
                    displayAltitude = `${altInFeet} ft`; // Display in feet
                } else {
                    // Handle hPa values and convert to feet for display
                    windSpeedKey = `windspeed_${alt}hPa`;
                    windDirectionKey = `winddirection_${alt}hPa`;
                    displayAltitude = `${hPaToFeet(alt)} ft`; // Covert hPa to feet and display in feet
                }

                // Check if wind data exists for this particular elevation
                if (weatherData.hourly.hasOwnProperty(windSpeedKey) && weatherData.hourly.hasOwnProperty(windDirectionKey)) {
                    tableHtml += `<tr><th class="sticky-header">${displayAltitude}</th>`;

                    // Iterate over wind speeds and directions together
                    weatherData.hourly[windSpeedKey].forEach((windSpeed, idx) => {
                        const windDirection = weatherData.hourly[windDirectionKey][idx];
                        const windArrowClass = getWindArrowClass(windDirection);
                        const roundedWindSpeed = windSpeed !== null ? Math.round(windSpeed) : '?';

                        // Get the background and text color based on the wind speed
                        const { backgroundColor, textColor } = getWindSpeedColor(roundedWindSpeed);

                        // We're using the upwards arrow Unicode symbol and rotating it using CSS
                        const windArrowUnicode = '&#x2191;&#xFE0E;'; // Upwards arrow (we'll rotate it using CSS)

                        // Add wind speed and a Unicode arrow for wind direction with the proper rotation
                        tableHtml += `<td class="data-cell" style="background-color: ${backgroundColor}; color: ${textColor};"
        data-wind-speed="${roundedWindSpeed}" data-wind-direction="${windDirection}">
        <div>${roundedWindSpeed}</div>
        <div class="${windArrowClass}">${windArrowUnicode}</div>
    </td>`;
                    });
                    

                    tableHtml += '</tr>';

                }
                
                }) ;
            
        

            // Finally, set the table's HTML to the newly created rows
            table.innerHTML = tableHtml;

            const windGustsKey = `wind_gusts_10m`;
            if (weatherData.hourly.hasOwnProperty(windGustsKey)) {
                // Start the gusts table row with a descriptive header
                tableHtml += `<tr><th class="sticky-header small-text-cell">Gusts</th>`;

                // Add a data cell for each time interval with wind gusts data
                weatherData.hourly[windGustsKey].forEach((windGust, idx) => {
                    const roundedWindGust = windGust !== null ? Math.round(windGust) : '?';

                    // Get the background and text color based on the wind gust speed
                    const { backgroundColor, textColor } = getWindSpeedColor(roundedWindGust);

                    // Add wind gust value with the appropriate color coding
                    tableHtml += `<td class="data-cell" style="background-color: ${backgroundColor}; color: ${textColor};">
                    <div>${roundedWindGust}</div>
                  </td>`;
                });

                // Close the gusts table row
                tableHtml += '</tr>';

            }
            if (additionalVariablesEnabled) {
                // Assuming weatherData.hourly['cape'] is an array of CAPE values at hourly intervals
                if (weatherData.hourly.hasOwnProperty('cape')) {
                    // Add CAPE row header
                    tableHtml += `<tr><th class="sticky-header small-text-cell">CAPE</th>`;

                    // Add CAPE data cells for each time interval
                    weatherData.hourly['cape'].forEach(capeValue => {
                        const { backgroundColor, textColor } = getCAPEColor(capeValue); // Get colors based on value
                        const shortCapeValue = formatCapeValue(capeValue); // Ensure this line is before its usage

                        // Add CAPE data cells with gradient background and contrast text
                        tableHtml += `<td class="data-cell small-text-cell" style="background-color: ${backgroundColor}; color: ${textColor};">${shortCapeValue}</td>`;
                    
                    });

                    // Close the CAPE table row
                    tableHtml += '</tr>';
                }
            }
            if (additionalVariablesEnabled && (table.id === 'gfs-table' || table.id === 'openmeteo-table')) {
                // Precipitation probability only exists for certain models
                if (weatherData.hourly.hasOwnProperty('precipitation_probability')) {
                    // Add precipitation probability row header
                    tableHtml += '<tr><th class="sticky-header small-text-cell">Precip %</th>';

                    // Add precipitation probability data cells for each time interval
                    weatherData.hourly.precipitation_probability.forEach(precipProbability => {
                        precipProbability = precipProbability !== null ? precipProbability : '?';  // Check for null values
                        const { backgroundColor, textColor } = getPrecipitationProbabilityColor(precipProbability);

                        // Substitute N/A for missing precipitation_probability values or add cell with the actual value
                        tableHtml += `<td class="data-cell small-text-cell" style="background-color: ${backgroundColor}; color: ${textColor};">${precipProbability !== '?' ? precipProbability: precipProbability}</td>`;
                    });

                    tableHtml += '</tr>';
                }
            }
            if (additionalVariablesEnabled && weatherData.hourly.hasOwnProperty('cloud_cover')) {
                // Add cloud cover row header
                tableHtml += `<tr><th class="sticky-header small-text-cell">Clouds</th>`;

                // Add cloud cover data cells for each time interval
                weatherData.hourly['cloud_cover'].forEach(cloudCover => {
                    const maxDarkness = 0.70; // Maximum darkness for cloud cover (70%)
                    const opacity = cloudCover * maxDarkness / 100;
                    const bgColor = `rgba(0, 0, 0, ${opacity})`; // Calculate background color based on cloud cover percentage

                    // Determine text color based on the darkness of the background
                    // If opacity is more than 0.5 (halfway to max darkness), use light text color
                    const textColor = (opacity > 0.5) ? 'white' : 'black';

                    tableHtml += `<td class="data-cell small-text-cell grey-bg" style="background-color: ${bgColor}; color: ${textColor};">${cloudCover}</td>`;
                });}
            // Finally, set the table's HTML to the newly created rows
            table.innerHTML = tableHtml;

            // New code to add black horizontal border below "33 ft" row
            const allRows = table.getElementsByTagName('tr');
            for (let i = 0; i < allRows.length; i++) {
                // Check if the first cell (header) contains "33 ft"
                if (allRows[i].cells[0].innerText === '33 ft') {
                    // If "33 ft" is found, set a black border below this row
                    // Check if the next row is "Gusts"
                    if (i < (allRows.length - 1) && allRows[i + 1].cells[0].innerText === 'Gusts') {
                        allRows[i].style.borderBottom = '4px solid black';
                        break; // Border applied, no need to continue loop
                    }
                }
            }
            toggleHighAltitude();
            
            toggleDaylightHours();
            if (windShearEnabled) {
                console.log('Wind Shear Enabled: Checking...');
                // Asynchronously call the wind shear check function
                displaywindshear();
                // Once completed, set the text to reflect the current state
                this.textContent = 'Disable Wind Shear';
                this.disabled = false; // Re-enable the button
            };
            enableAllButtons();
            addVerticalBordersBetweenDays();
            
        }


        

        function enableAllButtons() {
                const allButtons = document.querySelectorAll('button');
                allButtons.forEach(button => {
                    button.disabled = false; // Enable the button
                    button.style.opacity = 1; // Ensure full opacity for enabled buttons
                });
            }
        function formatCapeValue(value) {
                const stringValue = value.toString(); // Convert number to string for easy length check
                if (stringValue.length > 3) {
                    const shortenedValue = (value / 1000).toFixed(1); // Reduce to kilo (k) and round to 1 decimal place
                    return `${shortenedValue}k`; // Add the 'k' character to denote 'kilo'
                }
                return stringValue; // Return the original string if it's not too long
            }
        function getCAPEColor(capeValue) {
            let percentage;
            let backgroundColorRGB;
            let textColor = 'black'; // Default text color

            if (capeValue >= 2000) {
                backgroundColorRGB = { r: 255, g: 0, b: 0 }; // Red
            } else if (capeValue >= 1200) {
                percentage = (capeValue - 1200) / (2000 - 1200);
                backgroundColorRGB = interpolateColorRGB('yellow', 'red', percentage);
            } else if (capeValue >= 800) {
                percentage = (capeValue - 800) / (1200 - 800);
                backgroundColorRGB = interpolateColorRGB('green', 'yellow', percentage);
            } else if (capeValue >= 400) {
                percentage = (capeValue - 400) / (800 - 400);
                backgroundColorRGB = interpolateColorRGB('lightblue', 'green', percentage);
            } else {
                percentage = capeValue / 400;
                backgroundColorRGB = interpolateColorRGB('darkblue', 'lightblue', percentage);
            }

            // Set text color to white if background is dark
            if (isColorDark(backgroundColorRGB.r, backgroundColorRGB.g, backgroundColorRGB.b)) {
                textColor = 'white';
            }

            // Return the color in CSS rgb() format
            const backgroundColor = `rgb(${backgroundColorRGB.r}, ${backgroundColorRGB.g}, ${backgroundColorRGB.b})`;
            return { backgroundColor, textColor };
        }
        const colors = {
             maroon: { r: 128, g: 0, b: 0 }, // Maroon color
            blue: { r: 0, g: 0, b: 255 },
            green: { r: 0, g: 255, b: 0 },
            red: { r: 255, g: 0, b: 0 },
            yellow: { r: 255, g: 255, b: 0 },
            white: { r: 255, g: 255, b: 255 }, // Adding white
            lightblue: { r: 173, g: 216, b: 230 }, // Light blue color
            darkblue: { r: 0, g: 0, b: 139 } // Dark blue color
        };

        async function refreshWeatherDataAndTables(zipcode) {
            console.log('refreshWeatherDataAndTables');
            // Fetch coordinates from zipcode
            await getCoordinatesByZipcode(zipcode);

            // Fetch weather data
            await fetchAllModelsData();

            // Update tables (if necessary)
            resetTables();


        }

        function isColorDark(r, g, b) {
            // Calculate the luminance of the color using the approximate formula:
            // luminance = 0.299*R + 0.587*G + 0.114*B
            const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
            // If luminance is less than 128, we will consider the color to be "dark"
            return luminance < 128;
        }
        // Helper function to get the background color based on the wind speed
        function getWindSpeedColor(windSpeed) {
            let backgroundColorRGB;
            let textColor = 'black'; // Default text color

            if (windSpeed === '?') {
                backgroundColorRGB = { r: 255, g: 255, b: 255 }; // White background
                textColor = 'black';
            } else if (windSpeed <= lowWindThreshold) {
                backgroundColorRGB = { r: 0, g: 0, b: 255 }; // Blue background
            } else if (windSpeed >= highWindThreshold) {
                backgroundColorRGB = { r: 255, g: 0, b: 0 }; // Red background
            } else if (windSpeed <= medWindThreshold) {
                // Interpolating blue to green
                backgroundColorRGB = interpolateColorRGB('blue', 'green', (windSpeed - lowWindThreshold) / (medWindThreshold - lowWindThreshold));
            } else {
                // Interpolating green to red
                backgroundColorRGB = interpolateColorRGB('green', 'red', (windSpeed - medWindThreshold) / (highWindThreshold - medWindThreshold));
            }
            isColorDark();
            // Set text color to white if background is dark
            if (isColorDark(backgroundColorRGB.r, backgroundColorRGB.g, backgroundColorRGB.b)) {
                textColor = 'white';
            }

            // Return the color in CSS rgb() format
            const backgroundColor = `rgb(${backgroundColorRGB.r}, ${backgroundColorRGB.g}, ${backgroundColorRGB.b})`;
            return { backgroundColor, textColor };
        }
        function getPrecipitationProbabilityColor(value) {
            if (value === '?') {
                return {
                    backgroundColor: 'rgb(255, 255, 255)', // White color for N/A values
                    textColor: 'rgb(0, 0, 0)' // Black text color for better readability
                };
            }
            const backgroundColor = interpolateColorRGB('white', 'darkblue', value / 100);
            const textColor = isColorDark(backgroundColor.r, backgroundColor.g, backgroundColor.b) ? 'white' : 'black';
            return { backgroundColor: `rgb(${backgroundColor.r}, ${backgroundColor.g}, ${backgroundColor.b})`, textColor };
            
        }
        // Modify interpolate to return an object
        function interpolateColorRGB(color1, color2, percentage) {

            // Start and end colors as rgb objects
            const startColor = colors[color1];
            const endColor = colors[color2];

            // Make sure the color names are valid
            if (!startColor || !endColor) {
                throw new Error(`Invalid color names: "${color1}" or "${color2}"`);
            }

            // Interpolate each color channel
            const r = Math.round(startColor.r + (endColor.r - startColor.r) * percentage);
            const g = Math.round(startColor.g + (endColor.g - startColor.g) * percentage);
            const b = Math.round(startColor.b + (endColor.b - startColor.b) * percentage);

            // Return the interpolated color as an object
            return { r, g, b };
        }



        function fillTableWithCloudCover(table, weatherData) {
                console.log('fillTableWithCloudCover');
                const model = table.dataset.model;
                // Update showing attribute here
                table.dataset.showing = 'clouds';
                createTable(table.id, weatherData, model); // Reuse createTable function
                toggleHighAltitude();
                toggleDaylightHours();
            addVerticalBordersBetweenDays();
                // Disable all buttons except "Wind/Clouds" and "Temperature"
                disableButtonsExcept(['toggleButton', 'toggleTemperatureButton']);
                
            }

            function disableButtonsExcept(buttonIds) {
                    const allButtons = document.querySelectorAll('button');
                    allButtons.forEach(button => {
                        if (!buttonIds.includes(button.id) && button.id !== 'editButton') { // Exclude the edit button from being disabled
                            button.disabled = true; // Disable the button
                            button.style.opacity = 0.5; // Gray out the button visually
                        } else {
                            button.disabled = false; // Enable specified buttons
                            button.style.opacity = 1; // Ensure full opacity for enabled buttons
                        }
                    });
                }
        // Initialize the tables to display clouds by default
        document.querySelectorAll('table[id$="-table"]').forEach(table => {
            table.dataset.showing = 'winds'; // Default view
        });
        // Function to convert degrees to Unicode arrows with text-style rendering
        function getWindDirectionArrow(degrees) {
                if (typeof degrees === 'undefined' || degrees === null) {
                    return ''; // Return empty string if the direction is undefined or null
                }
                const arrows = {
                    S: '&#x2191;&#xFE0E;', // Upwards arrow (used to be North, now South)
                    SW: '&#x2197;&#xFE0E;', // North East arrow (used to be NE, now SW)
                    W: '&#x2192;&#xFE0E;', // Rightwards arrow (used to be East, now West)
                    NW: '&#x2198;&#xFE0E;', // South East arrow (used to be SE, now NW)
                    N: '&#x2193;&#xFE0E;', // Downwards arrow (used to be South, now North)
                    NE: '&#x2199;&#xFE0E;', // South West arrow (used to be SW, now NE)
                    E: '&#x2190;&#xFE0E;', // Leftwards arrow (used to be West, now East)
                    SE: '&#x2196;&#xFE0E;'  // North West arrow (used to be NW, now SE)
                };

                // Convert the degrees to an arrow string with the given mapping
                const directions = [
                    { direction: 'N', range: [337.5, 360], rangeStart: [0, 22.5] },
                    { direction: 'NE', range: [22.5, 67.5] },
                    { direction: 'E', range: [67.5, 112.5] },
                    { direction: 'SE', range: [112.5, 157.5] },
                    { direction: 'S', range: [157.5, 202.5] },
                    { direction: 'SW', range: [202.5, 247.5] },
                    { direction: 'W', range: [247.5, 292.5] },
                    { direction: 'NW', range: [292.5, 337.5] }
                ];

                for (let i = 0; i < directions.length; i++) {
                    const { direction, range, rangeStart } = directions[i];
                    if ((degrees >= range[0] && degrees < range[1]) || (rangeStart && degrees >= rangeStart[0] && degrees < rangeStart[1])) {
                        return arrows[direction]; // Return the Unicode arrow character for the direction
                    }
                 
                }
                return ''; // Return empty string if the direction does not fall within known ranges
            }
    document.addEventListener('DOMContentLoaded', () => {
        const collapseButton = document.getElementById('editButton');

        function clickCollapseButton() {
            // Check if the collapse button text is "Collapse" and click it
            if (collapseButton.textContent.trim() === 'Collapse') {
                collapseButton.click();
            }
        }

        // Array of button IDs that should trigger the collapse button click
        const buttonIdsToTriggerCollapse = [
            // Add all the button IDs that need to trigger the collapse
            'toggleButton', // Wind/Clouds button ID
            'toggleTemperatureButton', // Temperature button ID
            'submitThresholds', // Submit button ID (from config popup)
            'applyBestDaysButton', // Apply button ID (from best days popup)
            'checkWindShearButton', // Enable Wind Shear button ID
            'toggleDaylightButton', // All Hours/Daylight button ID
            'toggleHighAltitudeButton', // High Altitude button ID
            'additionalVariablesButton' // Toggle Additional Variables button ID
        ];

        buttonIdsToTriggerCollapse.forEach(buttonId => {
            const button = document.getElementById(buttonId);
            if (button) {
                button.addEventListener('click', () => {
                    // Perform the button's original action here if necessary...

                    // Then trigger the collapse button click after the action
                    clickCollapseButton();
                });
            }
        });

        // If there are more buttons with similar functionality that are not captured by ID,
        // you can assign them a common class and add event listeners based on that.
    });

    </script>

</body>

</html>