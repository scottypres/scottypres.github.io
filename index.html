<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Collection</title>
    <style>
        /* Add a general header class to apply common header styles across tables */
        #autocomplete-list {
            position: absolute;
            background: #fff;
            border: 1px solid #d4d4d4;
            z-index: 99;
        }

        .day-divider {
            border-right: 1px solid black;
            width: 0;
            /* No actual width, just the border */
        }

        .shear-detected {
            border: 2px solid white;
        }

        .shear-detected-hidden {
            border: 2px solid tnsparent !important;
            background-color: inherit !important;
            /* Optional: reset any coloring if needed */
        }

        #autocomplete-list div {
            padding: 10px;
            cursor: pointer;
        }

        #autocomplete-list div:hover {
            background-color: #e9e9e9;
        }

        .wind-arrow {
            display: inline-block;
            transform-origin: center;
            font-size: 14px;
            /* Additional styling here if needed */
        }

        .column-header {
            white-space: nowrap;
            background-color: white;
            text-align: center;
            font-family: Arial, sans-serif;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Add a general data cell class to apply common data cell styles */
        wind-arrow.rotate-0 {
            transform: rotate(0deg);
        }

        .wind-arrow.rotate-11-25 {
            transform: rotate(11.25deg);
        }

        .wind-arrow.rotate-22-50 {
            transform: rotate(22.50deg);
        }

        .wind-arrow.rotate-33-75 {
            transform: rotate(33.75deg);
        }

        .wind-arrow.rotate-45 {
            transform: rotate(45deg);
        }

        .wind-arrow.rotate-56-25 {
            transform: rotate(56.25deg);
        }

        .wind-arrow.rotate-67-50 {
            transform: rotate(67.50deg);
        }

        .wind-arrow.rotate-78-75 {
            transform: rotate(78.75deg);
        }

        .wind-arrow.rotate-90 {
            transform: rotate(90deg);
        }

        .wind-arrow.rotate-101-25 {
            transform: rotate(101.25deg);
        }

        .wind-arrow.rotate-112-50 {
            transform: rotate(112.50deg);
        }

        .wind-arrow.rotate-123-75 {
            transform: rotate(123.75deg);
        }

        .wind-arrow.rotate-135 {
            transform: rotate(135deg);
        }

        .wind-arrow.rotate-146-25 {
            transform: rotate(146.25deg);
        }

        .wind-arrow.rotate-157-50 {
            transform: rotate(157.50deg);
        }

        .wind-arrow.rotate-168-75 {
            transform: rotate(168.75deg);
        }

        .wind-arrow.rotate-180 {
            transform: rotate(180deg);
        }

        .wind-arrow.rotate-191-25 {
            transform: rotate(191.25deg);
        }

        .wind-arrow.rotate-202-50 {
            transform: rotate(202.50deg);
        }

        .wind-arrow.rotate-213-75 {
            transform: rotate(213.75deg);
        }

        .wind-arrow.rotate-225 {
            transform: rotate(225deg);
        }

        .wind-arrow.rotate-236-25 {
            transform: rotate(236.25deg);
        }

        .wind-arrow.rotate-247-50 {
            transform: rotate(247.50deg);
        }

        .wind-arrow.rotate-258-75 {
            transform: rotate(258.75deg);
        }

        .wind-arrow.rotate-270 {
            transform: rotate(270deg);
        }

        .wind-arrow.rotate-281-25 {
            transform: rotate(281.25deg);
        }

        .wind-arrow.rotate-292-50 {
            transform: rotate(292.50deg);
        }

        .wind-arrow.rotate-303-75 {
            transform: rotate(303.75deg);
        }

        .wind-arrow.rotate-315 {
            transform: rotate(315deg);
        }

        .wind-arrow.rotate-326-25 {
            transform: rotate(326.25deg);
        }

        .wind-arrow.rotate-337-50 {
            transform: rotate(337.50deg);
        }

        .wind-arrow.rotate-348-75 {
            transform: rotate(348.75deg);
        }

        .wind-arrow.rotate-360 {
            transform: rotate(360deg);
        }

        .data-cell {
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
        }

        .smalldate {
            font-size: 10px;
        }

        .small-font {
            font-size: 16px;
        }

        body {
            margin: 0;
            padding: 0;
        }

        .sticky-header {
            position: sticky;
            top: 0;
            background-color: white;
            z-index: 3;
        }




        .header h2 {
            /* Sticky positioning here is unnecessary as .sticky-header class already makes the header stick */
            margin: 0;
            /* The position, top, and background-color properties should be removed from here */
        }

        /* Add these CSS styles */
        th.daylight {
            border: 2px solid orange;
        }

        /* Updated CSS rule for first-column cells */
        table th:first-child,
        table td:first-child {
            position: sticky;
            left: 0;
            background-color: white;
            z-index: 2;

            min-width: 60px;
            max-width: 120px;
        }

        th span {
            font-size: 12px;
        }

        table {
            width: 100%;
            border-collapse: collapse;

        }

        th,
        td {
            min-width: 10px;
            /* Minimum width of cells */
            max-width: 50px;
            /* Maximum width of cells */
            border: 1px solid black;
            padding: 1px;
            text-align: center;
            font-family: Arial, sans-serif;
            overflow: hidden;
            /* If content is too wide, it will be clipped */
            text-overflow: ellipsis;
            /* If content is clipped, display an ellipsis ('...') */
            white-space: nowrap;
            /* Keep text on the same line */
        }

        .wind-arrow {
            display: inline-block;
            transform-origin: 50% 50%;
        }

        @for $i from 0 through 348 {
            $degrees: $i * 11.25;

            .wind-arrow.rotate-#{$degrees} {
                transform: rotate(#{$degrees}deg);
            }
        }

        /* Updated CSS rule for first-column cells under `tbody` to inherit the width */
        td:first-child {
            position: sticky;
            left: 0;
            background-color: white;
            z-index: 1;
        }

        td:not(:first-child) {
            white-space: nowrap;
            /* Prevent text wrapping in the data cells */
        }

        th {
            min-width: 20px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .grey-bg {
            /* Max grey level 75% */
            background-color: rgba(0, 0, 0, 0.75);
        }
    </style>
</head>

<body>

    <div id="zipcode-section">
        <label for="zipcodeInput">Enter Zipcode:</label>
        <input type="text" id="zipcodeInput" placeholder="Enter zipcode">
        <button id="fetchCoordinatesButton">Get Weather</button>
    </div>
    <div id="zipcode-section">
        <!-- ... existing HTML ... -->

        <button id="editThresholdsButton">Edit Wind Speed Thresholds</button>
        <button id="toggleButton">Wind/Clouds</button>
        <button id="toggleHighAltitudeButton">High Altitude</button>
        <button id="checkWindShearButton">Wind Shear</button>
        <button id="bestDaysButton" disabled>Best Days</button>
        <button id="toggleDaylightButton">Toggle Daylight Hours</button>

        <div id="bestDaysPopup" class="config-popup" style="display: none;">
            <div class="config-content">
                <label for="bestWindSpeed">Max Wind Speed</label>
                <input type="number" id="bestWindSpeed" value="15" min="0" /><br />
                <button id="applyBestDaysButton">Apply</button>
                
            </div>
        </div>
        
        
        <!-- ICON Table -->
        <div id="configPopup" class="config-popup" style="display: none;">
            <div class="config-content">
                <label for="blueThreshold">Blue Threshold (mph)</label>
                <input type="number" id="blueThreshold" value="4" min="0" /><br />
                <label for="greenThreshold">Green Threshold (mph)</label>
                <input type="number" id="greenThreshold" value="12" min="1" /><br />
                <label for="redThreshold">Red Threshold (mph)</label>
                <input type="number" id="redThreshold" value="20" min="2" /><br />
                <button id="submitThresholds">Submit</button>
            </div>

            <!-- GFS Table -->
            <table id="gfs-table">
                <!-- The table will be populated by JavaScript -->
            </table>
        </div>

        <!-- OpenMeteo Table -->
        <table id="openmeteo-table" style="margin-bottom: 20px;">
            <!-- The table will be populated by JavaScript -->
        </table>





        <table id="icon-table">
            <!-- The table will be populated by JavaScript -->
        </table>
    </div>


    <script>
        document.getElementById('checkWindShearButton').addEventListener('click', performWindShearChecksAndUpdateTables);
        document.getElementById('toggleHighAltitudeButton').addEventListener('click', toggleHighAltitude);
        function toggleHighAltitude() {
                const tables = document.querySelectorAll('table[id$="-table"]');
                tables.forEach(table => {
                    const rows = table.getElementsByTagName('tr');
                    // Skip the header row by starting the loop at index 1
                    for (let i = 1; i < rows.length; i++) {
                        const altitudeInFeet = rows[i].cells[0].innerText.replace(' ft', '');
                        if (parseInt(altitudeInFeet) > 5000) {
                            // Toggle the visibility of the row based on the current display state
                            if (rows[i].style.display !== 'none') {
                                rows[i].style.display = 'none';
                            } else {
                                rows[i].style.display = '';
                            }
                        }
                    }
                });
            }
            let daylightHoursShown = true;
        let userLocation = {
            latitude: 26.4187,   // Use a default latitude or prompt the user to enter a valid one.
            longitude: 81.4173,  // Use a default longitude or prompt the user to enter a valid one.
        };
        // Initialize global threshold variables
        lowWindThreshold = 7;
        medWindThreshold = 15;
        highWindThreshold = 20;
        // Declare this at the top to store the initial view
        let isWindShearChecked = false;
        let globalWeatherData = {};
        let bestWindSpeedThreshold = 15;
    document.getElementById('toggleDaylightButton').addEventListener('click', toggleDaylightHours);
        
        function toggleDaylightHours() {
                const tables = document.querySelectorAll('table[id$="-table"]'); // Select all tables that end with '-table'
                tables.forEach(table => {
                    const headerCells = table.querySelectorAll('tr:first-child th:not(:first-child)'); // Select all header cells except the first one

                    headerCells.forEach((cell, index) => {
                        // Toggle the display state based on the current flag
                        if (daylightHoursShown) {
                            // If daylight hours are currently shown, hide the non-daylight cells (cells without the 'daylight' class)
                            if (!cell.classList.contains('daylight')) {
                                cell.style.display = 'none';
                                [...table.querySelectorAll(`td:nth-child(${index + 2})`)].forEach(td => td.style.display = 'none');
                            }
                        } else {
                            // If daylight hours are currently hidden, show all cells
                            cell.style.display = '';
                            [...table.querySelectorAll(`td:nth-child(${index + 2})`)].forEach(td => td.style.display = '');
                        }
                    });
                });

                // Toggle the flag to the opposite state
                daylightHoursShown = !daylightHoursShown;
            }
        document.getElementById('bestDaysButton').addEventListener('click', function () {
                const buttonText = this.textContent;
                if (buttonText === 'Best Days') {
                    // The button text is "Best Days", so show the popup
                    document.getElementById('bestDaysPopup').style.display = 'flex';
                } else {
                    // The button text is "Reset", so reset the tables by creating them again
                    resetTables();
                    // Change the button text back to "Best Days"
                    this.textContent = 'Best Days';
                }
            });
            function resetTables() {
                    // Loop over each model to create the tables again using the stored data
                    Object.keys(globalWeatherData).forEach(model => {
                        const tableId = `${model.toLowerCase()}-table`;
                        createTable(tableId, globalWeatherData[model], model);
                    });
                    // After resetting the tables, update the toggle button text to reflect the content shown in the tables
                    
                    initialTableSetup();
                }

        // Event listener to handle when the user clicks the "Apply" button in the Best Days popup
        document.getElementById('applyBestDaysButton').addEventListener('click', function () {
    // Show "Loading..." and disable the button to prevent additional clicks during processing
    this.textContent = 'Loading...';
    this.disabled = true;

    // Get the value from the input field for the best wind speed threshold
    bestWindSpeedThreshold = parseFloat(document.getElementById('bestWindSpeed').value);
    setCookie('bestWindSpeed', bestWindSpeedThreshold, 365);
    // Perform the filtering operation asynchronously to allow the UI to show the loading state
    setTimeout(() => {
        filterBestDaysColumns();
        // After completing the filter operation, reset the Apply button and update the UI
        this.textContent = 'Apply';
        this.disabled = false;
        // Hide the best days filter popup
        document.getElementById('bestDaysPopup').style.display = 'none';
        // Change the Best Days button to Reset
        document.getElementById('bestDaysButton').textContent = 'Reset';
        // Show the Reset button
        
    }, 0);
});
    
function filterBestDaysColumns() {
            // Threshold in mph
            const bestWindSpeedThreshold = parseFloat(document.getElementById('bestWindSpeed').value);

            // Get tables containing wind speeds
            const tables = document.querySelectorAll('table[id$="-table"]');

            tables.forEach(table => {
                // Get all header cells (ignoring the first row which contains model names)
                const headers = table.querySelectorAll('tr:first-child th:not(:first-child)');
                // Get all rows to access speed values at specified altitudes
                const rows = table.querySelectorAll('tr:not(:first-child)');

                // Determine which rows correspond to altitudes 33, 262, and 361 ft
                const targetAltitudeRows = [...rows].filter(row => {
                    const altitudeText = row.cells[0].innerText.trim();
                    const altitude = parseInt(altitudeText.replace(' ft', ''), 10);
                    return [33, 262, 361].includes(altitude);
                });

                // Keep track of the last known day of week text to compare days


                // Iterate over each column (time slot) and check if values exceed the threshold
                headers.forEach((header, columnIndex) => {
                    // Extract day of week from the header cell, assuming the format is MM/DD\nDay\nHH\nAM/PM
                    const dayOfWeek = header.innerText.trim().split('\n')[1]; // Day of week is on the second line



                    // Check whether any of the wind speeds exceed the threshold
                    let columnOverThreshold = targetAltitudeRows.some(row => {
                        const windSpeedText = row.cells[columnIndex + 1].innerText.trim();
                        const windSpeed = parseFloat(windSpeedText);
                        return windSpeed > bestWindSpeedThreshold;
                    });

                    // Hide the whole column if the threshold is exceeded
                    if (columnOverThreshold) {
                        headers[columnIndex].style.display = 'none'; // Hide header cell
                        rows.forEach(row => {
                            row.cells[columnIndex + 1].style.display = 'none'; // Hide data cell
                        });
                    } else {
                        // Ensure the column is visible if it does not exceed the threshold
                        headers[columnIndex].style.display = ''; // Show header cell
                        rows.forEach(row => {
                            row.cells[columnIndex + 1].style.display = ''; // Show data cell
                        });
                    }
                });
            });
            
        }

        // After tables have been generated, enable the "Best Days" button
        function enableBestDaysButton() {
            const bestDaysButton = document.getElementById('bestDaysButton');
            if (bestDaysButton) {
                bestDaysButton.disabled = false; // Enable the button
            }
        }
        function getWindArrowClass(degrees) {

            // Normalize the degrees to ensure it is between 0 and 360
            degrees = (degrees + 180) % 360; // Add 180 degrees to flip the arrow direction
            // Round the degrees to the nearest 11.25 increment
            const roundedDegrees = Math.round(degrees / 11.25) * 11.25;
            // Replace dot with a dash for CSS class compatibility
            const classDegrees = roundedDegrees.toFixed(2).replace('.', '-');
            // Return the CSS class for the wind arrow rotation
            return 'wind-arrow rotate-' + classDegrees;
        }
        function initialTableSetup() {
                Object.keys(globalWeatherData).forEach(model => {
                    const tableId = `${model.toLowerCase()}-table`;
                    const dataTable = document.getElementById(tableId);
                    fillTableWithWindSpeed(dataTable, globalWeatherData[model]); // Show winds data first
                    dataTable.dataset.showing = 'winds'; // Indicate that winds are being shown
                });
              // toggleDaylightHours();
                toggleHighAltitude(); // Hide high altitude rows by default
            }
        function showConfigPopup() {
            document.getElementById('configPopup').style.display = 'flex';
        }
        // Fetch data for each model
        const baseUrls = {
            openMeteo: 'https://api.open-meteo.com/v1/forecast',
            //gfs: 'https://api.open-meteo.com/v1/gfs',
            icon: 'https://api.open-meteo.com/v1/dwd-icon'
        };
        //fetchAllModelsData();
        document.getElementById('editThresholdsButton').addEventListener('click', showConfigPopup); // assume editThresholdsButton is the ID of the button to show the popup
        function submitThresholdsAndRepaint() {
            // Get the threshold values from the input fields
            const blueThreshold = parseInt(document.getElementById('blueThreshold').value, 10);
            const greenThreshold = parseInt(document.getElementById('greenThreshold').value, 10);
            const redThreshold = parseInt(document.getElementById('redThreshold').value, 10);

            // Store them in cookies
            setCookie('blueThreshold', blueThreshold, 365);
            setCookie('greenThreshold', greenThreshold, 365);
            setCookie('redThreshold', redThreshold, 365);

            // Repaint the graph
            repaintGraphsWithNewThresholds(blueThreshold, greenThreshold, redThreshold);

            // Hide the config popup
            document.getElementById('configPopup').style.display = 'none';
        }

        document.getElementById('submitThresholds').addEventListener('click', submitThresholdsAndRepaint);
        function repaintGraphsWithNewThresholds(low, med, high) {
            // Assume these are the names of three different tables you have
            lowWindThreshold = low;
            medWindThreshold = med;
            highWindThreshold = high;

            const tableIds = ['openmeteo-table', 'icon-table']; // Add other table IDs as needed
            tableIds.forEach(tableId => {
                const table = document.getElementById(tableId);
                if (table.dataset.showing === 'winds') {
                    fillTableWithWindSpeed(table, globalWeatherData[table.dataset.model]);
                }
            });
        }
        function hPaToFeet(hPa) {
            const conversionTable = {
                1000: 110,
                975: 320,
                950: 500,
                925: 800,
                900: 1000,
                850: 1500,
                800: 1900,
                700: 3000,
                600: 4200,
                500: 5600,
                400: 7200
            };

            const meters = conversionTable[hPa];
            const feet = meters * 3.28084; // Convert meters to feet
            return Math.round(feet);
        }

        document.querySelectorAll('table[id$="-table"]').forEach(table => {
            table.dataset.showing = 'winds'; // Start with winds data shown
        });
        document.getElementById('fetchCoordinatesButton').addEventListener('click', () => {
            const zipcode = document.getElementById('zipcodeInput').value.trim();
            if (zipcode) {
                handleZipcodeFetch(zipcode);
            } else {
                alert('Please enter a valid zipcode.');
            }
        });

        async function fetchAllModelsData() {
            console.log("Inside fetchAllModelsData before Promise.all", new Date().toISOString());
            try {
                // Await all fetches to be completed using Promise.all
                await Promise.all(Object.entries(baseUrls).map(async ([model, baseUrl]) => {
                    console.log(`Fetching data for model "${model}"`, new Date().toISOString());
                    await checkAndFetchData(baseUrl, model);
                }));

                console.log("Inside fetchAllModelsData after Promise.all", new Date().toISOString());

                // Now that we have all data, setup the tables and perform shear checks
                initialTableSetup();
                
            } catch (error) {
                console.error('Error fetching data for all models:', error);
            }
        }

        // Fetch data for each model by calling the new fetchAllModelsData function
        //fetchAllModelsData();



        async function getCoordinatesByZipcode(zipcode) {
            console.log("getCoordinatesByZipcode called", new Date().toISOString());
            const zipApiUrl = `https://api.zippopotam.us/us/${zipcode}`;
            console.log("getCoordinatesByZipcode start", new Date().toISOString());
            try {
                const response = await fetch(zipApiUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                if (data && data.places.length > 0) {
                    // Update the global location variable
                    userLocation = {
                        latitude: parseFloat(data.places[0].latitude),
                        longitude: parseFloat(data.places[0].longitude)
                    };
                    //console.log('Coordinates:', userLocation);
                    setCookie('zipcode', zipcode, 365); // Save for 365 days
                    console.log('zip cookie saved');
                    // Now call the API with these coordinates for each model and update the table with new data
                    for (const model of Object.keys(baseUrls)) {
                        await checkAndFetchData(baseUrls[model], model);
                    }
                    initialTableSetup(); // Refresh the table setup
                    // performWindShearChecksAndUpdateTables();

                } else {
                    alert('No coordinates found for the provided zipcode.');
                }
            } catch (error) {
                console.error('Failed to fetch coordinates:', error);
                alert('Failed to get coordinates. Please check the zipcode and try again.');
            }

            console.log("getCoordinatesByZipcode end", new Date().toISOString());

            
        };

        async function checkAndFetchData(baseUrl, model) {
           // console.log(`checkAndFetchData called for model ${model}`, new Date().toISOString());
            const dailyParameters = [
                'weather_code',
                'temperature_2m_max',
                'temperature_2m_min',
                'apparent_temperature_max',
                'apparent_temperature_min',
                'sunrise',
                'sunset',
                'uv_index_max',
                'precipitation_sum'
            ].join(',');
            const commonParameters = [
                'temperature_2m', 'temperature_80m', 'temperature_180m',
                'weather_code', 'relative_humidity_2m',
                'dew_point_2m',
                'cloud_cover',
                'cloud_cover_low',
                'cloud_cover_mid',
                'cloud_cover_high',
                'cloud_cover_1000hPa',
                'cloud_cover_975hPa',
                'cloud_cover_950hPa',
                'cloud_cover_925hPa',
                'cloud_cover_900hPa',
                'cloud_cover_850hPa',
                'cloud_cover_800hPa',
                'cloud_cover_750hPa',
                'cloud_cover_700hPa',
                'cloud_cover_650hPa',
                'cloud_cover_600hPa',
                'cloud_cover_550hPa',
                'cloud_cover_500hPa',
                'cloud_cover_450hPa',
                'cloud_cover_400hPa',
                // Add new variables below
                'wind_speed_10m',
                'wind_speed_80m',
                'wind_speed_180m', 'wind_gusts_10m',
                'wind_direction_10m',
                'wind_direction_80m',
                'wind_direction_180m',
                'temperature_1000hPa',
                'temperature_975hPa',
                'temperature_950hPa',
                'temperature_925hPa',
                'temperature_900hPa',
                'temperature_850hPa',
                'temperature_800hPa',
                'temperature_700hPa',
                'temperature_600hPa',
                'temperature_500hPa',
                'temperature_400hPa',
                'windspeed_1000hPa',
                'windspeed_975hPa',
                'windspeed_950hPa',
                'windspeed_925hPa',
                'windspeed_900hPa',
                'windspeed_850hPa',
                'windspeed_800hPa',
                'windspeed_700hPa',
                'windspeed_600hPa',
                'windspeed_500hPa',
                'windspeed_400hPa',
                'winddirection_1000hPa',
                'winddirection_975hPa',
                'winddirection_950hPa',
                'winddirection_925hPa',
                'winddirection_900hPa',
                'winddirection_850hPa',
                'winddirection_800hPa',
                'winddirection_700hPa',
                'winddirection_600hPa',
                'winddirection_500hPa',
                'winddirection_400hPa',
                'cape',
                'is_day'
            ].join(',');


            const units = '&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto';
            let additionalParameters = ''; // Initialize additional parameters string

            // Check the model to determine the correct forecast_days parameter
            if (model.toLowerCase() === 'openmeteo') {
                additionalParameters += '&forecast_days=14'; // 14-day forecast for OpenMeteo
            } else if (model.toLowerCase() === 'icon') {
                additionalParameters += '&forecast_days=7'; // 7-day forecast for ICON
            }

            const zipcode = document.getElementById('zipcodeInput').value.trim();
            const lastApiCallKey = `lastApiCall_${model}_${zipcode}`;
            const now = Date.now();
            const cacheDuration = 15 * 60 * 1000; // 15 minutes in milliseconds
            const lastApiCallData = localStorage.getItem(lastApiCallKey);
            let shouldFetchData = true;

            // Check if we have cached data for this model and zipcode
            if (lastApiCallData) {
                const cachedData = JSON.parse(lastApiCallData);

                // Check if the cached data is still valid
                if (cachedData.zipcode === zipcode && now - cachedData.timestamp < cacheDuration) {
                    console.log(`Using cached data for model "${model}"`, new Date().toISOString());
                    globalWeatherData[model] = cachedData.data;
                    createTable(`${model.toLowerCase()}-table`, cachedData.data, model);
                    shouldFetchData = false;
                }
            }

            // Fetch new data if necessary
            if (shouldFetchData) {
                 const requestUrl = `${baseUrl}?latitude=${userLocation.latitude}&longitude=${userLocation.longitude}&hourly=${commonParameters}&daily=${dailyParameters}${units}${additionalParameters}`;

                try {
                    // Request data from the weather API using the assembled URL
                    const response = await fetch(requestUrl);

                    // If the response is not okay, throw an error
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    // Parse the response as JSON
                    const weatherData = await response.json();

                    // Cache the new API data
                    localStorage.setItem(lastApiCallKey, JSON.stringify({
                        timestamp: now,
                        data: weatherData,
                        zipcode: zipcode
                    }));

                    // Populate the respective table with the fetched data
                    createTable(`${model.toLowerCase()}-table`, weatherData, model);

                    // Store the fetched data globally
                    globalWeatherData[model] = weatherData;

                    console.log(`Data fetched successfully for model ${model}`);
                } catch (error) {
                    // Log the error if fetching the data fails
                    console.error(`Failed to fetch data for model ${model}`, error);
                    // Optionally, handle the error in the UI
                }
            }

           // console.log(`checkAndFetchData finished for model ${model}`, new Date().toISOString());
        }



        function setCookie(name, value, days) {
            const d = new Date();
            d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
            const expires = `expires=${d.toUTCString()}`;
            document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)};${expires};path=/`;
        }

        function getCookie(name) {
            const cname = `${encodeURIComponent(name)}=`;
            const decodedCookie = decodeURIComponent(document.cookie);
            const ca = decodedCookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(cname) === 0) {
                    return c.substring(cname.length, c.length);
                }
            }
            return "";
        }


    


        window.onload = function () {
            console.log("Window onload triggered", new Date().toISOString());

            // Get threshold values from cookies, if they exist
            const blueThreshold = getCookie('blueThreshold');
            const greenThreshold = getCookie('greenThreshold');
            const redThreshold = getCookie('redThreshold');

            // Update threshold inputs with cookie values
            if (blueThreshold) document.getElementById('blueThreshold').value = blueThreshold;
            if (greenThreshold) document.getElementById('greenThreshold').value = greenThreshold;
            if (redThreshold) document.getElementById('redThreshold').value = redThreshold;

            // Check for the presence of the zipcode cookie
            const savedZipcode = getCookie('zipcode');

            if (savedZipcode) {
                const zipcodeInput = document.getElementById('zipcodeInput');

                const fetchButton = document.getElementById('fetchCoordinatesButton');

                zipcodeInput.value = savedZipcode;
                console.log("Zip cookie loaded");
                // Check if fetchCoordinatesButton has already a click event listener that fetches the weather
                // If not, manually call the handleZipcodeFetch(zipcode) function after a short delay to ensure any setup logic has completed
                setTimeout(function () {
                    fetchButton.click();
                }, 0);
            }
            const savedBestWindSpeed = getCookie('bestWindSpeed');

            if (savedBestWindSpeed) {
                // If we have a saved value, use it as the best wind speed threshold
                bestWindSpeedThreshold = parseFloat(savedBestWindSpeed);
            } else {
                // If no value is saved, use default value
                bestWindSpeedThreshold = 15;
            }

            // Update the value in the input field
            document.getElementById('bestWindSpeed').value = bestWindSpeedThreshold;
        };
        async function handleZipcodeFetch(zipcode) {
            // Disable the button and recent search links to prevent multiple fetches
            document.getElementById('fetchCoordinatesButton').disabled = true;
            document.querySelectorAll('.recent-search').forEach(elem => elem.style.pointerEvents = 'none');

            // Fetch the coordinates and update the tables
            await getCoordinatesByZipcode(zipcode);
            // Re-enable the button and the recent search links
            document.getElementById('fetchCoordinatesButton').disabled = false;
            document.querySelectorAll('.recent-search').forEach(elem => elem.style.pointerEvents = '');
        }
    function expandDaylightHours(isDayArray) {
        let foundFirstOne = false; // Flag that becomes true when we encounter the first '1'
        let lastZeroBeforeOneIndex = -1; // Store the index of the last '0' before the sequence of '1's

        // Iterate over the array
        for (let i = 0; i < isDayArray.length; i++) {
            if (isDayArray[i] === 1) {
                foundFirstOne = true;
                // If this is the first '1', change the previous '0' to '1'
                if (lastZeroBeforeOneIndex !== -1) {
                    isDayArray[lastZeroBeforeOneIndex] = 1;
                    lastZeroBeforeOneIndex = -1; // Reset the index
                }
            } else if (foundFirstOne) {
                // If we found the sequence of '1's and now we encountered a '0', change it to '1' and reset flags
                isDayArray[i] = 1;
                foundFirstOne = false; // Reset the flag until we find another '1'
            } else {
                // If we have not encountered the first '1' yet, store the index
                lastZeroBeforeOneIndex = i;
            }
        }
        return isDayArray;
    }

        function createTable(tableId, weatherData, model) {
            console.log(globalWeatherData);
            const altitudeLabels = [1000, 975, 950, 925, 900, 850, 800, 700, 600, 500, 400].reverse();
            const timestamps = weatherData.hourly.time;
            const dataTable = document.getElementById(tableId);
            isWindShearChecked = false;

            let tableHtml = `<tr><th>${model.replace('Meteo', '<br>Meteo')}</th>`;
            let currentDay = null; // Variable to store the current day as you loop through the timestamps
             // Assuming that weatherData.hourly.is_day is an array with the same length as timestamps
            let isDayArray = weatherData.hourly.is_day;
            
            // Add date headers
            console.log(isDayArray);
            timestamps.forEach((timestamp, index) => {
                const date = new Date(timestamp);
                const day = date.getDate();
                const month = date.getMonth() + 1;
                const dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'short' }).slice(0, 2); // Use first two letters
                const hour = date.getHours();
                const hour12 = hour % 12 || 12; // Convert to 12-hour format
                const ampm = hour >= 12 ? 'PM' : 'AM';
                // Determine if the timestamp corresponds to daylight using is_day array
                const isDaylight = isDayArray[index] === 1;
                const daylightClass = isDaylight ? 'daylight' : '';

              
                // Add "daylight" class to header cells of daylight hours
                //const isDaylight = hour >= 6 && hour < 18;
               // const headerClass = isDaylight ? 'daylight' : '';

               headerClass = '';
                tableHtml += `<th class="column-header ${daylightClass}">
                    <span class="smalldate">${month}/${day}</span><br>
                    <span class="small-font">${dayOfWeek}</span><br>
                    <span class="small-font">${hour12}</span><br><span class="small-font">${ampm}</span>
                  </th>`;
                enableBestDaysButton();
            });


            tableHtml += '</tr>';

            // Add rows for each altitude
            altitudeLabels.forEach(hPa => {
                // Convert hPa to feet for the display label
                const feet = hPaToFeet(hPa);

                // Start the table row with the altitude label
                tableHtml += `<tr><th class="sticky-header">${feet} ft</th>`;

                // Presuming the weatherData variable holds your cloud cover data indexed by hPa, 
                // e.g., `cloud_cover_1000hPa`, `cloud_cover_975hPa`, etc.
                const cloudCoverKey = `cloud_cover_${hPa}hPa`;
                const allShearCells = document.querySelectorAll('.shear-detected, .shear-detected-hidden');
                allShearCells.forEach(cell => {
                    cell.classList.remove('shear-detected');
                });
                // Check if the cloud cover data exists for this altitude level
                if (weatherData.hourly.hasOwnProperty(cloudCoverKey)) {
                    // Add a data cell for each time interval
                    weatherData.hourly[cloudCoverKey].forEach(cloudCover => {
                        // Calculate the background color based on cloud cover percentage
                        const bgColor = `rgba(0, 0, 0, ${cloudCover * 0.75 / 100})`;

                        // Append the data cell with styling for cloud cover
                        tableHtml += `<td class="grey-bg" style="background-color: ${bgColor}"></td>`;
                    });
                } else {
                    // If cloud cover data does not exist for this pressure altitude (hPa), span across all time intervals
                    tableHtml += `<td colspan="${weatherData.hourly.time.length}" class="data-cell">Data not available</td>`;
                }

                // Close the table row
                tableHtml += '</tr>';
            });

            dataTable.innerHTML = tableHtml;




            dataTable.dataset.model = model;
            //console.log(`Listeners added for ${model} model`);
        }
        
        document.getElementById('toggleButton').addEventListener('click', toggleWindClouds);
        document.getElementById('toggleButton').textContent = 'Winds/Clouds'; // Default text
        function toggleWindClouds() {
            Object.keys(globalWeatherData).forEach(model => {
                const tableId = `${model.toLowerCase()}-table`;
                const dataTable = document.getElementById(tableId);
                const currentDisplay = dataTable.dataset.showing;

                if (currentDisplay === 'clouds') {
                    // Display wind data
                    fillTableWithWindSpeed(dataTable, globalWeatherData[model]);
                    dataTable.dataset.showing = 'winds';
                } else {
                    // Display cloud cover data
                    fillTableWithCloudCover(dataTable, globalWeatherData[model]);
                    dataTable.dataset.showing = 'clouds';
                }
            });

            
        }

        

        // Call this function to set the initial state of the button
        
        function fillTableWithWindSpeed(table, weatherData) {
            let tableHtml = '<tr>' + table.getElementsByTagName('tr')[0].innerHTML + '</tr>';
            const altitudeLevels = [10, 80, 1000, 180, 975, 950, 925, 900, 850, 800, 700, 600, 500, 400].reverse(); // Order hPa values and feet values in descending order
            let gustRowAdded = false; // Flag to control the addition of the gust row
            altitudeLevels.forEach(alt => {
                let windSpeedKey, windDirectionKey;
                let displayAltitude; // Define a variable to hold our display altitude

                if (alt === 10 || alt === 80 || alt === 180) {
                    // Handle the specific feet values (10m, 80m, 180m are in meters, need conversion to feet)
                    const altInFeet = Math.round(alt * 3.28084); // Convert meters to feet, rounding to the nearest whole number
                    windSpeedKey = `wind_speed_${alt}m`;
                    windDirectionKey = `wind_direction_${alt}m`;
                    displayAltitude = `${altInFeet} ft`; // Display in feet
                } else {
                    // Handle hPa values and convert to feet for display
                    windSpeedKey = `windspeed_${alt}hPa`;
                    windDirectionKey = `winddirection_${alt}hPa`;
                    displayAltitude = `${hPaToFeet(alt)} ft`; // Covert hPa to feet and display in feet
                }

                // Check if wind data exists for this particular elevation
                if (weatherData.hourly.hasOwnProperty(windSpeedKey) && weatherData.hourly.hasOwnProperty(windDirectionKey)) {
                    tableHtml += `<tr><th class="sticky-header">${displayAltitude}</th>`;

                    // Iterate over wind speeds and directions together
                    weatherData.hourly[windSpeedKey].forEach((windSpeed, idx) => {
                        const windDirection = weatherData.hourly[windDirectionKey][idx];
                        const windArrowClass = getWindArrowClass(windDirection);
                        const roundedWindSpeed = windSpeed !== null ? Math.round(windSpeed) : 'N/A';

                        // Get the background and text color based on the wind speed
                        const { backgroundColor, textColor } = getWindSpeedColor(roundedWindSpeed);
                        const windArrowUnicode = getWindDirectionArrow(windDirection);
                        // Add wind speed and a Unicode arrow for wind direction with the proper rotation
                        tableHtml += `<td class="data-cell" style="background-color: ${backgroundColor}; color: ${textColor};" data-wind-angle="${windDirection}">
                    <div>${roundedWindSpeed}</div>
                    <div class="${windArrowClass}">${windArrowUnicode}</div>
                  </td>`;

                    });

                    // Close the table row
                    tableHtml += '</tr>';
                }
            });

            // Finally, set the table's HTML to the newly created rows
            table.innerHTML = tableHtml;
            const windGustsKey = `wind_gusts_10m`;
            if (weatherData.hourly.hasOwnProperty(windGustsKey)) {
                // Start the gusts table row with a descriptive header
                tableHtml += `<tr><th class="sticky-header">Gusts</th>`;

                // Add a data cell for each time interval with wind gusts data
                weatherData.hourly[windGustsKey].forEach((windGust, idx) => {
                    const roundedWindGust = windGust !== null ? Math.round(windGust) : 'N/A';

                    // Get the background and text color based on the wind gust speed
                    const { backgroundColor, textColor } = getWindSpeedColor(roundedWindGust);

                    // Add wind gust value with the appropriate color coding
                    tableHtml += `<td class="data-cell" style="background-color: ${backgroundColor}; color: ${textColor};">
                    <div>${roundedWindGust}</div>
                  </td>`;
                });

                // Close the gusts table row
                tableHtml += '</tr>';
            }

            // Finally, set the table's HTML to the newly created rows
            table.innerHTML = tableHtml;


        }


        async function refreshWeatherDataAndTables(zipcode) {
            // Fetch coordinates from zipcode
            await getCoordinatesByZipcode(zipcode);
            // Fetch weather data
            await fetchAllModelsData();
            // Update tables (if necessary)
            updateWeatherTables();
            // Perform wind shear checks (if necessary)
            performWindShearChecksAndUpdateTables();
        }
        function performWindShearChecksAndUpdateTables() {
                // Get reference to the Wind Shear button
                const windShearButton = document.getElementById('checkWindShearButton');
                // Change the button text to show "Loading..."
                windShearButton.textContent = 'Loading...';
                windShearButton.disabled = true; // Disable the button during processing

                // Process in the next tick to let the UI update
                setTimeout(() => {
                    const tables = document.querySelectorAll('table[id$="-table"]');
                    isWindShearChecked = !isWindShearChecked; // Toggle the state

                    tables.forEach(table => {
                        if (table.dataset.showing === 'winds') {
                            const rows = table.rows;
                            for (let colIndex = 1; colIndex < rows[0].cells.length; colIndex++) {
                                for (let rowIndex = 1; rowIndex < rows.length - 1; rowIndex++) {
                                    const cellCurrentSpeed = parseFloat(rows[rowIndex].cells[colIndex].innerText.trim());
                                    const cellNextSpeed = parseFloat(rows[rowIndex + 1].cells[colIndex].innerText.trim());

                                    const cellCurrentAltitude = parseInt(rows[rowIndex].cells[0].innerText.replace(' ft', ''));
                                    const cellNextAltitude = parseInt(rows[rowIndex + 1].cells[0].innerText.replace(' ft', ''));
                                    const altitudeDifference = Math.abs(cellCurrentAltitude - cellNextAltitude);

                                    const cellCurrentAngle = parseFloat(rows[rowIndex].cells[colIndex].dataset.windAngle);
                                    const cellNextAngle = parseFloat(rows[rowIndex + 1].cells[colIndex].dataset.windAngle);

                                    if (!isNaN(cellCurrentSpeed) && !isNaN(cellNextSpeed) && !isNaN(cellCurrentAngle) && !isNaN(cellNextAngle) && altitudeDifference < 1650) {
                                        const diffSpeed = Math.abs(cellCurrentSpeed - cellNextSpeed);
                                        let diffAngle = Math.abs(cellCurrentAngle - cellNextAngle) % 360;
                                        diffAngle = diffAngle > 180 ? 360 - diffAngle : diffAngle; // Normalize angle difference to range [0, 180]

                                        if (diffSpeed > 10 || diffAngle > 90) { // Adjust your speed and angle thresholds as needed
                                            rows[rowIndex].cells[colIndex].classList.toggle('shear-detected', isWindShearChecked);
                                            rows[rowIndex + 1].cells[colIndex].classList.toggle('shear-detected', isWindShearChecked);
                                        } else {
                                            rows[rowIndex].cells[colIndex].classList.remove('shear-detected');
                                            rows[rowIndex + 1].cells[colIndex].classList.remove('shear-detected');
                                        }
                                    } else {
                                        // If the cell represents a high altitude, above the threshold, skip it
                                        if (cellCurrentAltitude => 4922){
                                            continue;
                                        
                                        rows[rowIndex].cells[colIndex].classList.remove('shear-detected');
                                        rows[rowIndex + 1].cells[colIndex].classList.remove('shear-detected');}
                                    }
                                }
                            }
                        }
                    });

                    // Once done, update the button text to reflect the toggled state
                    windShearButton.textContent = isWindShearChecked ? 'Hide Wind Shear' : 'Show Wind Shear';
                    windShearButton.disabled = false; // Re-enable the button after processing
                }, 0);
            }

            // Attach the event handler to the button
            document.getElementById('checkWindShearButton').addEventListener('click', performWindShearChecksAndUpdateTables);
        
        // Helper function to get the background color based on the wind speed
        function getWindSpeedColor(windSpeed) {
            let backgroundColorRGB;
            let textColor = 'black'; // Default text color

            if (windSpeed === 'N/A') {
                backgroundColorRGB = { r: 255, g: 255, b: 255 }; // White background
                textColor = 'black';
            } else if (windSpeed <= lowWindThreshold) {
                backgroundColorRGB = { r: 0, g: 0, b: 255 }; // Blue background
            } else if (windSpeed >= highWindThreshold) {
                backgroundColorRGB = { r: 255, g: 0, b: 0 }; // Red background
            } else if (windSpeed <= medWindThreshold) {
                // Interpolating blue to green
                backgroundColorRGB = interpolateColorRGB('blue', 'green', (windSpeed - lowWindThreshold) / (medWindThreshold - lowWindThreshold));
            } else {
                // Interpolating green to red
                backgroundColorRGB = interpolateColorRGB('green', 'red', (windSpeed - medWindThreshold) / (highWindThreshold - medWindThreshold));
            }
            function isColorDark(r, g, b) {
                // Calculate the luminance of the color using the approximate formula:
                // luminance = 0.299*R + 0.587*G + 0.114*B
                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                // If luminance is less than 128, we will consider the color to be "dark"
                return luminance < 128;
            }
            // Set text color to white if background is dark
            if (isColorDark(backgroundColorRGB.r, backgroundColorRGB.g, backgroundColorRGB.b)) {
                textColor = 'white';
            }

            // Return the color in CSS rgb() format
            const backgroundColor = `rgb(${backgroundColorRGB.r}, ${backgroundColorRGB.g}, ${backgroundColorRGB.b})`;
            return { backgroundColor, textColor };
        }

        // Modify interpolate to return an object
        function interpolateColorRGB(color1, color2, percentage) {
            // Predefined colors as rgb values
            const colors = {
                blue: { r: 0, g: 0, b: 255 },
                green: { r: 0, g: 255, b: 0 },
                red: { r: 255, g: 0, b: 0 }
            };

            // Start and end colors as rgb objects
            const startColor = colors[color1];
            const endColor = colors[color2];

            // Make sure the color names are valid
            if (!startColor || !endColor) {
                throw new Error(`Invalid color names: "${color1}" or "${color2}"`);
            }

            // Interpolate each color channel
            const r = Math.round(startColor.r + (endColor.r - startColor.r) * percentage);
            const g = Math.round(startColor.g + (endColor.g - startColor.g) * percentage);
            const b = Math.round(startColor.b + (endColor.b - startColor.b) * percentage);

            // Return the interpolated color as an object
            return { r, g, b };
        }

        // Function to interpolate between two colors based on a percentage (0 to 1)
        function interpolateColor(color1, color2, percentage) {
            // Function will use basic color interpolation between blue, green, and red
            const colors = { blue: [0, 0, 255], green: [0, 255, 0], red: [255, 0, 0] };
            const startColor = colors[color1];
            const endColor = colors[color2];

            // Interpolate each color channel
            const r = Math.round(startColor[0] + (endColor[0] - startColor[0]) * percentage);
            const g = Math.round(startColor[1] + (endColor[1] - startColor[1]) * percentage);
            const b = Math.round(startColor[2] + (endColor[2] - startColor[2]) * percentage);

            // Return the interpolated color in CSS rgb() format
            return `rgb(${r}, ${g}, ${b})`;
        }

        function fillTableWithCloudCover(table, weatherData) {
            const model = table.dataset.model;
            // Update showing attribute here
            table.dataset.showing = 'clouds';
            createTable(table.id, weatherData, model); // Reuse createTable function
        }
        // Initialize the tables to display clouds by default
        document.querySelectorAll('table[id$="-table"]').forEach(table => {
            table.dataset.showing = 'clouds'; // Default view
        });
        // Function to convert degrees to Unicode arrows with text-style rendering
        function getWindDirectionArrow(degrees) {
            if (typeof degrees === 'undefined' || degrees === null) {
                return ''; // Return empty string if the direction is undefined or null
            }
            const arrows = {
                N: '&#x2191;&#xFE0E;', // Upwards arrow
                NE: '&#x2197;&#xFE0E;', // North East arrow
                E: '&#x2192;&#xFE0E;', // Rightwards arrow
                SE: '&#x2198;&#xFE0E;', // South East arrow
                S: '&#x2193;&#xFE0E;', // Downwards arrow
                SW: '&#x2199;&#xFE0E;', // South West arrow
                W: '&#x2190;&#xFE0E;', // Leftwards arrow
                NW: '&#x2196;&#xFE0E;'  // North West arrow
            };

            // Convert the degrees to an arrow string with the given mapping
            const directions = [
                { direction: 'N', range: [337.5, 360], rangeStart: [0, 22.5] },
                { direction: 'NE', range: [22.5, 67.5] },
                { direction: 'E', range: [67.5, 112.5] },
                { direction: 'SE', range: [112.5, 157.5] },
                { direction: 'S', range: [157.5, 202.5] },
                { direction: 'SW', range: [202.5, 247.5] },
                { direction: 'W', range: [247.5, 292.5] },
                { direction: 'NW', range: [292.5, 337.5] }
            ];

            for (let i = 0; i < directions.length; i++) {
                const { direction, range, rangeStart } = directions[i];
                if ((degrees >= range[0] && degrees < range[1]) || (rangeStart && degrees >= rangeStart[0] && degrees < rangeStart[1])) {
                    return arrows[direction]; // Return the Unicode arrow character for the direction
                }
            }
            return ''; // Return empty string if the direction does not fall within known ranges
        }
        

    </script>

</body>

</html>